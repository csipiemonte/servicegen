«IMPORT servicegen»
«IMPORT servicedef»
«IMPORT typedef»
«IMPORT appresources»
«IMPORT svcorch»

«IMPORT template::javavalidator»

«EXTENSION template::ServicegenExtensions»
«EXTENSION template::flowmodel::FlowModelExtensions»

«DEFINE baseHandlers FOR SOABEModel»
	«EXPAND dataSlotHelper FOR this»
 
	«EXPAND startNodeBaseHandler FOR this»
	«EXPAND stopNodeBaseHandler FOR this»
	«EXPAND papdCallBaseHandler FOR this»
	«EXPAND wsCallBaseHandler FOR this»
	«EXPAND forEachBaseHandler FOR this»
	«EXPAND endLoopBaseHandler FOR this»
	«EXPAND checkCondBaseHandler FOR this»
	«EXPAND customTransformBaseHandler FOR this»
	«EXPAND declTransformBaseHandler FOR this»
«ENDDEFINE»

«DEFINE dataSlotHelper FOR SOABEModel»
«FILE dataSlotHelperFile()»package «baseHandlersPkg()»;

import com.opensymphony.module.propertyset.PropertySet;

/**
 * Classe di utilita' per la gestione dei data-slot all'interno del contesto di esecuzione 
 * di osworkflow.
 *
 */
public class DataSlotHelper {
	
public static Object getDataSlotValue(String name, PropertySet ps){
	return ps.getObject(name);
}

public static void setDataSlotValue(String name, Object val, PropertySet ps) {
		if (val!=null){
			ps.setObject(name, val);
		}
		else{
			ps.remove(name);
		}
}

public static Object initDataSlotValue(Class type){
	try {
		Object ris = type.newInstance();
		return ris;
	} catch (InstantiationException e) {
		throw new IllegalArgumentException("impossibile istanziare lo slot di tipo "+type+":"+e);
	} catch (IllegalAccessException e) {
		throw new IllegalArgumentException("impossibile istanziare lo slot di tipo "+type+":"+e);
	}
}

}

«ENDFILE»
«ENDDEFINE»

«DEFINE startNodeBaseHandler FOR SOABEModel»
«FILE startNodeBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.*;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

public abstract class «startNodeBaseHandlerClassName()» implements FunctionProvider {

	public final static String INPUT_BINDING_PARAM_PREFIX = "input.binding.";
	
	protected Map<String, String> _inputNameBindings;

	public void execute(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {

		this.initFunctionHandler(transientVars, args, ps);

		this.eseguiFunctionHandler(transientVars, args, ps);

		this.releaseFunctionHandler(transientVars, args, ps);
	}

	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {
		_inputNameBindings = new HashMap<String, String>();
		Iterator argnames_it = args.keySet().iterator();
		while(argnames_it.hasNext()){
			String currArgName =(String)argnames_it.next();
			if (!currArgName.startsWith(INPUT_BINDING_PARAM_PREFIX))
				continue;
			
			String currArgVal = (String)args.get(currArgName);
			StringTokenizer stok = new StringTokenizer(currArgVal,"=");
			if (stok.countTokens()!=2)
				throw new WorkflowException("Errore nell'inizializzazione del workflow: il formato del parametro "+
						currArgName+" deve essere <nomeparametro>=<nomedataslot>, invece è "+currArgVal);
			else{
				String currInput=stok.nextToken();
				String currDS = stok.nextToken();
				_inputNameBindings.put(currInput, currDS);
			}
		}
	}

	private void releaseFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
	}

	/**
	 * Copia i valori dei parametri di input nei rispettivi DataSlot, 
	 * prendendo le informazioni di mapping da _inputNameBindings
	 * @param transientVars
	 * @param args
	 * @param ps
	 * @throws WorkflowException
	 */
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		Iterator<String> paramNames_it = _inputNameBindings.keySet().iterator();
		while (paramNames_it.hasNext()) {
			String currParamName = paramNames_it.next();
			String currDSName = _inputNameBindings.get(currParamName);
			DataSlotHelper.setDataSlotValue(currDSName, DataSlotHelper
					.getDataSlotValue("input.parameter."
							+ currParamName, ps), ps);
		}
	}

}
«ENDFILE»
«ENDDEFINE»

«DEFINE stopNodeBaseHandler FOR SOABEModel»
«FILE stopNodeBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

public class «stopNodeBaseHandlerClassName()» implements FunctionProvider {

	public final static String OUTPUT_BINDING_PARAM = "output.binding";
	public final static String RETURN_ATTRIBUTE_NAME = "result";

	protected String _outputbindingName;

	public void execute(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {

		this.initFunctionHandler(transientVars, args, ps);

		this.eseguiFunctionHandler(transientVars, args, ps);

		this.releaseFunctionHandler(transientVars, args, ps);
	}

	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {
		// se il parametro non e' valorizzato l'operazione viene considerata void
		_outputbindingName = (String) args.get(OUTPUT_BINDING_PARAM);

	}

	private void releaseFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
	}

	/**
	 * Ricopia il valore del dataSlot di output nell'attributo "result", che
	 * sarà utilizzato nel metodo di orchestrazione come fonte del valore
	 * di ritorno (se _outputbindingname==null => void)
	 * @param transientVars
	 * @param args
	 * @param ps
	 * @throws WorkflowException
	 */
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		if (_outputbindingName != null) {
			Object retVal = DataSlotHelper
					.getDataSlotValue(_outputbindingName, ps);
			if (retVal != null)
				DataSlotHelper.setDataSlotValue(RETURN_ATTRIBUTE_NAME, retVal, ps);
		}
	}

}
«ENDFILE»
«ENDDEFINE»

«DEFINE papdCallBaseHandler FOR SOABEModel»
«FILE papdCallBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

public abstract class «papdCallBaseHandlerClassName()» implements FunctionProvider {

   

    public void execute(Map transientVars, Map args, PropertySet ps)	throws WorkflowException {
		
		this.initFunctionHandler(transientVars,args,ps);
		
		this.eseguiFunctionHandler(transientVars,args,ps);
		
		this.releaseFunctionHandler(transientVars,args,ps);
	}

		
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
		
		
	}
	
    private void releaseFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
	}
    
    
	public abstract void eseguiFunctionHandler(Map transientVars, Map args, PropertySet ps) throws  WorkflowException;
	
}

«ENDFILE»
«ENDDEFINE»

«DEFINE wsCallBaseHandler FOR SOABEModel»
«FILE wsCallBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

public abstract class «wsCallBaseHandlerClassName()» implements FunctionProvider {

   

    public void execute(Map transientVars, Map args, PropertySet ps)	throws WorkflowException {
		
		this.initFunctionHandler(transientVars,args,ps);
		
		this.eseguiFunctionHandler(transientVars,args,ps);
		
		this.releaseFunctionHandler(transientVars,args,ps);
	}

		
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
		
		
	}
	
    private void releaseFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
	}
    
    
	public abstract void eseguiFunctionHandler(Map transientVars, Map args, PropertySet ps) throws  WorkflowException;
	
}

«ENDFILE»
«ENDDEFINE»

«DEFINE forEachBaseHandler FOR SOABEModel»
«FILE forEachBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

public abstract class «forEachBaseHandlerClassName()» implements FunctionProvider {

   

    public void execute(Map transientVars, Map args, PropertySet ps)	throws WorkflowException {
		
		this.initFunctionHandler(transientVars,args,ps);
		
		this.eseguiFunctionHandler(transientVars,args,ps);
		
		this.releaseFunctionHandler(transientVars,args,ps);
	}

		
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
		
		
	}
	
    private void releaseFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
	}
    
    
	public abstract void eseguiFunctionHandler(Map transientVars, Map args, PropertySet ps) throws  WorkflowException;
	
}

«ENDFILE»
«ENDDEFINE»


«DEFINE endLoopBaseHandler FOR SOABEModel»
«FILE endLoopBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

public abstract class «endLoopBaseHandlerClassName()» implements FunctionProvider {

   

    public void execute(Map transientVars, Map args, PropertySet ps)	throws WorkflowException {
		
		this.initFunctionHandler(transientVars,args,ps);
		
		this.eseguiFunctionHandler(transientVars,args,ps);
		
		this.releaseFunctionHandler(transientVars,args,ps);
	}

		
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
		
		
	}
	
    private void releaseFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
	}
    
    
	public abstract void eseguiFunctionHandler(Map transientVars, Map args, PropertySet ps) throws  WorkflowException;
	
}

«ENDFILE»
«ENDDEFINE»


«DEFINE checkCondBaseHandler FOR SOABEModel»
«FILE checkCondBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

public abstract class «checkCondBaseHandlerClassName()» implements FunctionProvider {

   

    public void execute(Map transientVars, Map args, PropertySet ps)	throws WorkflowException {
		
		this.initFunctionHandler(transientVars,args,ps);
		
		this.eseguiFunctionHandler(transientVars,args,ps);
		
		this.releaseFunctionHandler(transientVars,args,ps);
	}

		
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
		
		
	}
	
    private void releaseFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
	}
    
    
	public abstract void eseguiFunctionHandler(Map transientVars, Map args, PropertySet ps) throws  WorkflowException;
	
}

«ENDFILE»
«ENDDEFINE»

«DEFINE customTransformBaseHandler FOR SOABEModel»
«FILE customTransformBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.*;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

/**
 * Classe base per la gestione delle trasformazioni custom (hand written). 
 */
public abstract class «customTransformBaseHandlerClassName()» implements FunctionProvider {

	public static final String INPUT_SLOT_NAME_PARAM_PREFIX = "input.slot.name.";
	public static final String INPUT_SLOT_CLASS_PARAM_PREFIX = "input.slot.class.";
	public static final String OUTPUT_SLOT_NAME_PARAM = "output.slot.name";
	public static final String OUTPUT_SLOT_CLASS_PARAM = "output.slot.class";
	public static final String INIT_OUTPUT_PARAM = "output.slot.init";

	protected ArrayList<String> _inputSlotNames;
	protected ArrayList<Class> _inputSlotTypes;
	protected String _outputSlotName;
	protected Class _outputSlotType;
	protected boolean _initOutSlot = false;

	public void execute(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {

		this.initFunctionHandler(transientVars, args, ps);

		this.eseguiFunctionHandler(transientVars, args, ps);

		this.releaseFunctionHandler(transientVars, args, ps);
	}

	protected void initFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		// input slots
		_inputSlotNames = new ArrayList<String>();
		_inputSlotTypes = new ArrayList<Class>();
		Iterator<String> argnames_it = args.keySet().iterator();
		while(argnames_it.hasNext()){
			String currArgname = argnames_it.next();
			String currArgVal = null;
			if (currArgname.startsWith(INPUT_SLOT_NAME_PARAM_PREFIX)){
				currArgVal = (String)args.get(currArgname);
				_inputSlotNames.add(currArgVal);
			}
			else if (currArgname.startsWith(INPUT_SLOT_CLASS_PARAM_PREFIX)){
				currArgVal = (String)args.get(currArgname);
				try {
					Class currSlotType = Class.forName(currArgVal);
					_inputSlotTypes.add(currSlotType);
				} catch (ClassNotFoundException e) {
					throw new WorkflowException("Errore nell'inizializzazione dell handler:"+e);
				}
			}
		}
		// out slot
		String outSlotName = (String)args.get(OUTPUT_SLOT_NAME_PARAM);
		if (outSlotName!=null){
			_outputSlotName=outSlotName;
			String outClassName = (String)args.get(OUTPUT_SLOT_CLASS_PARAM);
			try {
				Class outSlotType = Class.forName(outClassName);
				_outputSlotType=outSlotType;
			} catch (ClassNotFoundException e) {
				throw new WorkflowException("Errore nell'inizializzazione dell handler:"+e);
			}
		}
		else 
			throw new WorkflowException("Errore interno nell'inizializzazione dell'hanlder: output slot nullo");
	}

	protected void releaseFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
	}

	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		Map<String, Object> inputs = new HashMap<String, Object>();
		
		for (int i = 0; i < _inputSlotNames.size(); i++) {
			String currInSlotName = _inputSlotNames.get(i);
			Object currInSlotVal = ps.getObject(currInSlotName);
			inputs.put(currInSlotName, currInSlotVal);
		}
		Object outVal = getTransformedObject(inputs);
		DataSlotHelper.setDataSlotValue(_outputSlotName, outVal, ps);
	}

	/**
	 * Questo metodo deve essere ridefinito nelle sottoclassi specifiche con la logica 
	 * di trasformazione vera e propria.
	 *  
	 * @param inValues mappa contenente i valori dei dataSlot di input. Per trasformazioni
	 * incrementali anche il dataSlot di output può essere un dataSlot di input.
	 * @return l'oggetto trasformato, che verrà rimpiazzato al valore eventualmente precedente
	 * nel context.
	 */
	public abstract Object getTransformedObject(Map<String, Object> inValues);

}
«ENDFILE»
«ENDDEFINE»

«DEFINE declTransformBaseHandler FOR SOABEModel»
«FILE declTransformBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

public abstract class «declTransformBaseHandlerClassName()» extends «customTransformBaseHandlerClassName()» {
   
	public abstract Object getTransformedObject(Map<String, Object> inputs);
	
}

«ENDFILE»
«ENDDEFINE»

«REM»crea gli handler relativi ad una singola orchestrazione«ENDREM»
«DEFINE svcflowHandlerFiles(ServiceDef sd, SOABEModel model) FOR Operation»
«LET findOrchestrationForOperation(sd, model) AS currentOrchModel»
«IF currentOrchModel!=null»
	«EXPAND svcflowHandlers(sd, model) FOR currentOrchModel»
«ELSE»
«ERROR "Inconsistenza: impossibile trovare l'orchestrazione relativa al servizio "+sd.codServizio+", op: "+this.name»
«ENDIF»
«ENDLET»
«ENDDEFINE»

«DEFINE svcflowHandlers(ServiceDef sd, SOABEModel model) FOR Orchestration»
	«EXPAND svcflowHandler(this, sd, model) FOREACH this.nodes.nodes»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR Node»
«ERROR "Tipo di nodo non gestito"»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR StartNode»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «startNodeBaseHandlerClassName()»{
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR StopNode»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «stopNodeBaseHandlerClassName()»{
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR PAPDCall»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «papdCallBaseHandlerClassName()»{
	@Override
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		// TODO Auto-generated method stub
		
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR WSCall»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «wsCallBaseHandlerClassName()»{
	@Override
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		// TODO Auto-generated method stub
		
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR CustomTransformation»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «customTransformBaseHandlerClassName()»{

	
	public Object getTransformedObject(Map<String, Object> inputs){
		
		«map2JavaTypeSDRelative(output.type)» outVal = 
		 («map2JavaTypeSDRelative(output.type)»)(inputs.get(_outputSlotName));
		
		/// valore degli input slot
		«FOREACH input AS currIn-»
		«map2JavaTypeSDRelative(currIn.type)» slot_«currIn.name»  = 
			(«map2JavaTypeSDRelative(currIn.type)»)inputs.get("«getDataSlotAttrName(currIn)»");
		«ENDFOREACH-»
		
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"customTXLogic")»
		/// inserire qui la logica di trasformazione
		«ENDPROTECT»
		return outVal;
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR DeclarativeTransformation»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «declTransformBaseHandlerClassName()»{

	public «specificHandlerClassName()»(String inSlotNames[],
			Class inSlotTypes[], String outSlotName, Class outSlotType,
			boolean initOutSlot) {
			super(inSlotNames, inSlotTypes, outSlotName, outSlotType, initOutSlot);
	}

	public Object getTransformedObject(Map<String, Object> inputs){
		
		///// TODO
		return null;
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR ForEach»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «forEachBaseHandlerClassName()»{
	@Override
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		// TODO Auto-generated method stub
		
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR EndLoop»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «endLoopBaseHandlerClassName()»{
	@Override
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		// TODO Auto-generated method stub
		
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR CheckCondition»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «checkCondBaseHandlerClassName()»{
	@Override
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		// TODO Auto-generated method stub
		
	}
}
«ENDFILE»
«ENDDEFINE»


«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR UserDefinedOpNode»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;
import com.opensymphony.workflow.FunctionProvider;

import «baseHandlersPkg(model)».*;

«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"extraImport")»
// inserire qui eventuali import aggiuntive
«ENDPROTECT»

public class «specificHandlerClassName()» implements FunctionProvider{
	public void execute(Map transientVars, Map args, PropertySet ps)	throws WorkflowException {
		
		this.initFunctionHandler(transientVars,args,ps);
		
		this.eseguiFunctionHandler(transientVars,args,ps);
		
		this.releaseFunctionHandler(transientVars,args,ps);
	}

		
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"init")»
		«ENDPROTECT»
		
	}
	
    private void releaseFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
    	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"release")»
		«ENDPROTECT»
	}
    
    
	public void eseguiFunctionHandler(Map transientVars, Map args, PropertySet ps) throws  WorkflowException{
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"exec")»
		«ENDPROTECT»
	}
	
	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"extraMethods")»
	////// inserire qui eventuali metodi di supporto
	«ENDPROTECT»
	
	}
«ENDFILE»
«ENDDEFINE»