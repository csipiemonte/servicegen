«IMPORT servicegen»
«IMPORT servicedef»
«IMPORT typedef»
«IMPORT appresources»
«IMPORT svcorch»

«IMPORT template::javavalidator»

«EXTENSION template::ServicegenExtensions»
«EXTENSION template::flowmodel::FlowModelExtensions»

«DEFINE baseHandlers FOR SOABEModel»
	«EXPAND dataSlotHelper FOR this»
 
	«EXPAND startNodeBaseHandler FOR this»
	«EXPAND stopNodeBaseHandler FOR this»
	«EXPAND papdCallBaseHandler FOR this»
	«EXPAND wsCallBaseHandler FOR this»
	«EXPAND forEachBaseHandler FOR this»
	«EXPAND endLoopBaseHandler FOR this»
	«EXPAND checkCondBaseHandler FOR this»
	«EXPAND customTransformBaseHandler FOR this»
	«EXPAND declTransformBaseHandler FOR this»
	
	«EXPAND forEachConditionClass FOR this»
«ENDDEFINE»

«DEFINE dataSlotHelper FOR SOABEModel»
«FILE dataSlotHelperFile()»package «baseHandlersPkg()»;

import java.lang.reflect.Array;
import com.opensymphony.module.propertyset.PropertySet;

/**
 * Classe di utilita' per la gestione dei data-slot all'interno del contesto di esecuzione 
 * di osworkflow.
 *
 */
public class DataSlotHelper {
	
public static Object getDataSlotValue(String name, PropertySet ps){
	return ps.getObject(name);
}

public static void setDataSlotValue(String name, Object val, PropertySet ps) {
		if (val!=null){
			ps.setObject(name, val);
		}
		else{
			ps.remove(name);
		}
}

public static Object initDataSlotValue(Class type){
	try {
		Object ris = type.newInstance();
		return ris;
	} catch (InstantiationException e) {
		throw new IllegalArgumentException("impossibile istanziare lo slot di tipo "+type+":"+e);
	} catch (IllegalAccessException e) {
		throw new IllegalArgumentException("impossibile istanziare lo slot di tipo "+type+":"+e);
	}
}

public static Class classForName(String clname) throws ClassNotFoundException{
	if (clname.endsWith("[]")){
		String compName = clname.substring(0,clname.length()-2);
		Object dummyArr = Array.newInstance(classForName(compName), 0);
		return dummyArr.getClass();
	}
	else{
		return Class.forName(clname);
	}
}
}

«ENDFILE»
«ENDDEFINE»

«DEFINE startNodeBaseHandler FOR SOABEModel»
«FILE startNodeBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.*;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

public abstract class «startNodeBaseHandlerClassName()» implements FunctionProvider {

	public final static String INPUT_BINDING_PARAM_PREFIX = "input.binding.";
	
	protected Map<String, String> _inputNameBindings;

	public void execute(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {

		this.initFunctionHandler(transientVars, args, ps);

		this.eseguiFunctionHandler(transientVars, args, ps);

		this.releaseFunctionHandler(transientVars, args, ps);
	}

	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {
		_inputNameBindings = new HashMap<String, String>();
		Iterator argnames_it = args.keySet().iterator();
		while(argnames_it.hasNext()){
			String currArgName =(String)argnames_it.next();
			if (!currArgName.startsWith(INPUT_BINDING_PARAM_PREFIX))
				continue;
			
			String currArgVal = (String)args.get(currArgName);
			StringTokenizer stok = new StringTokenizer(currArgVal,"=");
			if (stok.countTokens()!=2)
				throw new WorkflowException("Errore nell'inizializzazione del workflow: il formato del parametro "+
						currArgName+" deve essere <nomeparametro>=<nomedataslot>, invece è "+currArgVal);
			else{
				String currInput=stok.nextToken();
				String currDS = stok.nextToken();
				_inputNameBindings.put(currInput, currDS);
			}
		}
	}

	private void releaseFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
	}

	/**
	 * Copia i valori dei parametri di input nei rispettivi DataSlot, 
	 * prendendo le informazioni di mapping da _inputNameBindings
	 * @param transientVars
	 * @param args
	 * @param ps
	 * @throws WorkflowException
	 */
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		Iterator<String> paramNames_it = _inputNameBindings.keySet().iterator();
		while (paramNames_it.hasNext()) {
			String currParamName = paramNames_it.next();
			String currDSName = _inputNameBindings.get(currParamName);
			DataSlotHelper.setDataSlotValue(currDSName, DataSlotHelper
					.getDataSlotValue("input.parameter."
							+ currParamName, ps), ps);
		}
	}

}
«ENDFILE»
«ENDDEFINE»

«DEFINE stopNodeBaseHandler FOR SOABEModel»
«FILE stopNodeBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

public class «stopNodeBaseHandlerClassName()» implements FunctionProvider {

	public final static String OUTPUT_BINDING_PARAM = "output.binding";
	public final static String RETURN_ATTRIBUTE_NAME = "result";

	protected String _outputbindingName;

	public void execute(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {

		this.initFunctionHandler(transientVars, args, ps);

		this.eseguiFunctionHandler(transientVars, args, ps);

		this.releaseFunctionHandler(transientVars, args, ps);
	}

	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {
		// se il parametro non e' valorizzato l'operazione viene considerata void
		_outputbindingName = (String) args.get(OUTPUT_BINDING_PARAM);

	}

	private void releaseFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
	}

	/**
	 * Ricopia il valore del dataSlot di output nell'attributo "result", che
	 * sarà utilizzato nel metodo di orchestrazione come fonte del valore
	 * di ritorno (se _outputbindingname==null => void)
	 * @param transientVars
	 * @param args
	 * @param ps
	 * @throws WorkflowException
	 */
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		if (_outputbindingName != null) {
			Object retVal = DataSlotHelper
					.getDataSlotValue(_outputbindingName, ps);
			if (retVal != null)
				DataSlotHelper.setDataSlotValue(RETURN_ATTRIBUTE_NAME, retVal, ps);
		}
	}

}
«ENDFILE»
«ENDDEFINE»

«DEFINE papdCallBaseHandler FOR SOABEModel»
«FILE papdCallBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

public abstract class «papdCallBaseHandlerClassName()» implements FunctionProvider {

	protected String selectorRes=null;
	
	protected String localPDRes=null;
	
	public final static String SELECTORPD_PARAM="selectorPD";
	public final static String SERVICEPD_PARAM="servicePD";
	
	public void execute(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {

		this.initFunctionHandler(transientVars, args, ps);

		this.eseguiFunctionHandler(transientVars, args, ps);

		this.releaseFunctionHandler(transientVars, args, ps);
	}

	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {
		selectorRes = (String)args.get(SELECTORPD_PARAM);
		if (selectorRes==null && selectorRes.length()==0){
			throw new WorkflowException("Errore nella inizializzazione dell' handler PDPACall: "+
					"occorre configurare il percorso del file del selettore tramite il "+
					"parametro "+SELECTORPD_PARAM);
		}
		else
			selectorRes="/"+selectorRes;
			
		localPDRes = (String)args.get(SERVICEPD_PARAM);
		if (localPDRes==null && localPDRes.length()==0){
			throw new WorkflowException("Errore nella inizializzazione dell' handler PDPACall: "+
					"occorre configurare il percorso del file della PD Locale tramite il "+
					"parametro "+SERVICEPD_PARAM);
		}
		else
			localPDRes = "/"+localPDRes;
		
	}

	private void releaseFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
	}

	public abstract void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException;
	
}

«ENDFILE»
«ENDDEFINE»

«DEFINE wsCallBaseHandler FOR SOABEModel»
«FILE wsCallBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

public abstract class «wsCallBaseHandlerClassName()» implements FunctionProvider {

   

    public void execute(Map transientVars, Map args, PropertySet ps)	throws WorkflowException {
		
		this.initFunctionHandler(transientVars,args,ps);
		
		this.eseguiFunctionHandler(transientVars,args,ps);
		
		this.releaseFunctionHandler(transientVars,args,ps);
	}

		
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
		
		
	}
	
    private void releaseFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
	}
    
    
	public abstract void eseguiFunctionHandler(Map transientVars, Map args, PropertySet ps) throws  WorkflowException;
	
}

«ENDFILE»
«ENDDEFINE»

«DEFINE forEachBaseHandler FOR SOABEModel»
«FILE forEachBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.*;
import java.lang.reflect.Array;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

public class «forEachBaseHandlerClassName()» implements FunctionProvider {

	public final static String COLLECTION_SLOT_NAME_PARAM_NAME = "collection.slot.name";
	public final static String ITEM_SLOT_NAME_PARAM_NAME = "item.slot.name";
	
	public final static String ITERATOR_SLOT_NAME_SUFFIX = "_for_each_iterator";
	public final static String MORE_ELEMENTS_SLOT_NAME_SUFFIX = "_has_more_elements";
	
	protected String _collectionSlotName;
	protected String _itemSlotName;
	
	public void execute(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {

		this.initFunctionHandler(transientVars, args, ps);

		this.eseguiFunctionHandler(transientVars, args, ps);

		this.releaseFunctionHandler(transientVars, args, ps);
	}

	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {
		String collSN = (String)args.get(COLLECTION_SLOT_NAME_PARAM_NAME);
		String itemSN = (String)args.get(ITEM_SLOT_NAME_PARAM_NAME);
		if (collSN==null || collSN.length()==0)
			throw new WorkflowException("Errore nell'inizializzazione dell handler ForEach: non è stato impostato il parametro "+COLLECTION_SLOT_NAME_PARAM_NAME);
		if (itemSN==null || itemSN.length()==0)
			throw new WorkflowException("Errore nell'inizializzazione dell handler ForEach: non è stato impostato il parametro "+ITEM_SLOT_NAME_PARAM_NAME);
		//
		_collectionSlotName=collSN.trim();
		_itemSlotName=itemSN.trim();
	}

	private void releaseFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
	}

	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException{
		// e' il primo giro?
		Iterator iterator = (Iterator)DataSlotHelper.getDataSlotValue(_collectionSlotName+ITERATOR_SLOT_NAME_SUFFIX, ps);
		if (iterator==null){
			// inizializza il loop
			Object collectionVal = DataSlotHelper.getDataSlotValue(_collectionSlotName, ps);
			if(collectionVal == null)
				throw new WorkflowException("Errore nel loop: collezione nulla");
					
			// la collection dovrebbe essere di tipo array (garantito da check) 
			if (!collectionVal.getClass().isArray())
				throw new WorkflowException("Errore durante iniziualizzazione ForEach: il tipo della collection "+_collectionSlotName+
						" non è un typed array ma "+collectionVal.getClass());
			else{
				// ok vai
				ArrayList coll = new ArrayList();
				if (collectionVal!=null){
					int sz =Array.getLength(collectionVal);
					for (Object curr : (Object[])collectionVal) {
						coll.add(curr);
					}
				}
				iterator = coll.iterator();
				DataSlotHelper.setDataSlotValue(_collectionSlotName+ITERATOR_SLOT_NAME_SUFFIX, iterator, ps);
			}
		}
		
		// in ogni caso verifica se ci sono ancora elementi e carica il prossimo
		if (iterator.hasNext()){
			Object next = iterator.next();
			// rende disponibile il prossimo elemento nello slot item
			DataSlotHelper.setDataSlotValue(_itemSlotName, next, ps);
			// imposta al condizione di loop a true
			DataSlotHelper.setDataSlotValue(_collectionSlotName+MORE_ELEMENTS_SLOT_NAME_SUFFIX, Boolean.TRUE, ps);
		}
		else{
			// rimuove dal property set l'attributo di iterazione
			DataSlotHelper.setDataSlotValue(_itemSlotName, null, ps);
			DataSlotHelper.setDataSlotValue(_collectionSlotName+ITERATOR_SLOT_NAME_SUFFIX, null, ps);
			DataSlotHelper.setDataSlotValue(_collectionSlotName+MORE_ELEMENTS_SLOT_NAME_SUFFIX, null, ps);
			// imposta la condizione di loop a false
			DataSlotHelper.setDataSlotValue(_collectionSlotName+MORE_ELEMENTS_SLOT_NAME_SUFFIX, Boolean.FALSE, ps);
		}
	}
}

«ENDFILE»
«ENDDEFINE»


«DEFINE endLoopBaseHandler FOR SOABEModel»
«FILE endLoopBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

public abstract class «endLoopBaseHandlerClassName()» implements FunctionProvider {

   

    public void execute(Map transientVars, Map args, PropertySet ps)	throws WorkflowException {
		
		this.initFunctionHandler(transientVars,args,ps);
		
		this.eseguiFunctionHandler(transientVars,args,ps);
		
		this.releaseFunctionHandler(transientVars,args,ps);
	}

		
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
		
		
	}
	
    private void releaseFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
	}
    
    
	public abstract void eseguiFunctionHandler(Map transientVars, Map args, PropertySet ps) throws  WorkflowException;
	
}

«ENDFILE»
«ENDDEFINE»


«DEFINE checkCondBaseHandler FOR SOABEModel»
«FILE checkCondBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

public abstract class «checkCondBaseHandlerClassName()» implements FunctionProvider {

   

    public void execute(Map transientVars, Map args, PropertySet ps)	throws WorkflowException {
		
		this.initFunctionHandler(transientVars,args,ps);
		
		this.eseguiFunctionHandler(transientVars,args,ps);
		
		this.releaseFunctionHandler(transientVars,args,ps);
	}

		
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
		
		
	}
	
    private void releaseFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
	}
    
    
	public abstract void eseguiFunctionHandler(Map transientVars, Map args, PropertySet ps) throws  WorkflowException;
	
}

«ENDFILE»
«ENDDEFINE»

«DEFINE customTransformBaseHandler FOR SOABEModel»
«FILE customTransformBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.*;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

/**
 * Classe base per la gestione delle trasformazioni custom (hand written). 
 */
public abstract class «customTransformBaseHandlerClassName()» implements FunctionProvider {

	public static final String INPUT_SLOT_NAME_PARAM_PREFIX = "input.slot.name.";
	public static final String INPUT_SLOT_CLASS_PARAM_PREFIX = "input.slot.class.";
	public static final String OUTPUT_SLOT_NAME_PARAM = "output.slot.name";
	public static final String OUTPUT_SLOT_CLASS_PARAM = "output.slot.class";
	public static final String INIT_OUTPUT_PARAM = "output.slot.init";

	protected ArrayList<String> _inputSlotNames;
	protected ArrayList<Class> _inputSlotTypes;
	protected String _outputSlotName;
	protected Class _outputSlotType;
	protected boolean _initOutSlot = false;

	public void execute(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {

		this.initFunctionHandler(transientVars, args, ps);

		this.eseguiFunctionHandler(transientVars, args, ps);

		this.releaseFunctionHandler(transientVars, args, ps);
	}

	protected void initFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		// input slots
		_inputSlotNames = new ArrayList<String>();
		_inputSlotTypes = new ArrayList<Class>();
		Iterator<String> argnames_it = args.keySet().iterator();
		while(argnames_it.hasNext()){
			String currArgname = argnames_it.next();
			String currArgVal = null;
			if (currArgname.startsWith(INPUT_SLOT_NAME_PARAM_PREFIX)){
				currArgVal = (String)args.get(currArgname);
				_inputSlotNames.add(currArgVal);
			}
			else if (currArgname.startsWith(INPUT_SLOT_CLASS_PARAM_PREFIX)){
				currArgVal = (String)args.get(currArgname);
				try {
					Class currSlotType = DataSlotHelper.classForName(currArgVal.trim());
					_inputSlotTypes.add(currSlotType);
				} catch (ClassNotFoundException e) {
					throw new WorkflowException("Errore nell'inizializzazione dell handler:"+e);
				}
			}
		}
		// out slot
		String outSlotName = (String)args.get(OUTPUT_SLOT_NAME_PARAM);
		if (outSlotName!=null){
			_outputSlotName=outSlotName.trim();
			String outClassName = (String)args.get(OUTPUT_SLOT_CLASS_PARAM);
			try {
				Class outSlotType = DataSlotHelper.classForName(outClassName);
				_outputSlotType=outSlotType;
			} catch (ClassNotFoundException e) {
				throw new WorkflowException("Errore nell'inizializzazione dell handler:"+e);
			}
		}
		else 
			throw new WorkflowException("Errore interno nell'inizializzazione dell'hanlder: output slot nullo");
	}

	protected void releaseFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
	}

	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		Map<String, Object> inputs = new HashMap<String, Object>();
		
		for (int i = 0; i < _inputSlotNames.size(); i++) {
			String currInSlotName = _inputSlotNames.get(i);
			Object currInSlotVal = ps.getObject(currInSlotName);
			inputs.put(currInSlotName, currInSlotVal);
		}
		Object outVal = getTransformedObject(inputs);
		DataSlotHelper.setDataSlotValue(_outputSlotName, outVal, ps);
	}

	/**
	 * Questo metodo deve essere ridefinito nelle sottoclassi specifiche con la logica 
	 * di trasformazione vera e propria.
	 *  
	 * @param inValues mappa contenente i valori dei dataSlot di input. Per trasformazioni
	 * incrementali anche il dataSlot di output può essere un dataSlot di input.
	 * @return l'oggetto trasformato, che verrà rimpiazzato al valore eventualmente precedente
	 * nel context.
	 */
	public abstract Object getTransformedObject(Map<String, Object> inValues);

}
«ENDFILE»
«ENDDEFINE»

«DEFINE declTransformBaseHandler FOR SOABEModel»
«FILE declTransformBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

public abstract class «declTransformBaseHandlerClassName()» extends «customTransformBaseHandlerClassName()» {
   
	public abstract Object getTransformedObject(Map<String, Object> inputs);
	
}

«ENDFILE»
«ENDDEFINE»

«DEFINE forEachConditionClass FOR SOABEModel»
«FILE forEachConditionFile()»package «baseHandlersPkg()»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.Condition;
import com.opensymphony.workflow.WorkflowException;

public class «forEachConditionClassName()» implements Condition{

	public final static String BRANCH_PARAM_NAME = "for.each.branch";
	public final static String STAY="stay";
	public final static String EXIT="exit";
	
	public boolean passesCondition(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {
		String collSN = (String)args.get(ForEachBaseHandler.COLLECTION_SLOT_NAME_PARAM_NAME);
		if (collSN==null)
			throw new WorkflowException("errore nella configurazione della condizione del for each: occorre configurare "+
					"il parametro "+ForEachBaseHandler.COLLECTION_SLOT_NAME_PARAM_NAME+ 
					" valorizzandolo coerentemente con il nodo for each corrispondente.");
		
		String branch = (String)args.get(BRANCH_PARAM_NAME);
		if (branch == null || 
			(!branch.equals(STAY)&&!branch.equals(EXIT))
		){
			throw new WorkflowException("errore nella configurazione della condizione del for each: occorre configurare "+
					"il parametro "+BRANCH_PARAM_NAME+ 
					" valorizzandolo con '"+STAY+"' o '"+EXIT+"'");
		}
		Boolean continueFlag = (Boolean)DataSlotHelper.getDataSlotValue(collSN+ForEachBaseHandler.MORE_ELEMENTS_SLOT_NAME_SUFFIX, ps);
		if (continueFlag==null)
			continueFlag=Boolean.FALSE;
		if (branch.equals(STAY))
			return continueFlag.booleanValue();
		else
			return !continueFlag.booleanValue();
		
	}
}
«ENDFILE»
«ENDDEFINE»

«REM»crea gli handler relativi ad una singola orchestrazione«ENDREM»
«DEFINE svcflowHandlerFiles(ServiceDef sd, SOABEModel model) FOR Operation»
«LET findOrchestrationForOperation(sd, model) AS currentOrchModel»
«IF currentOrchModel!=null»
	«EXPAND svcflowHandlers(sd, model) FOR currentOrchModel»
«ELSE»
«ERROR "Inconsistenza: impossibile trovare l'orchestrazione relativa al servizio "+sd.codServizio+", op: "+this.name»
«ENDIF»
«ENDLET»
«ENDDEFINE»

«DEFINE svcflowHandlers(ServiceDef sd, SOABEModel model) FOR Orchestration»
	«EXPAND svcflowHandler(this, sd, model) FOREACH this.nodes.nodes»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR Node»
«ERROR "Tipo di nodo non gestito"»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR StartNode»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «startNodeBaseHandlerClassName()»{
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR StopNode»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «stopNodeBaseHandlerClassName()»{
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR PAPDCall»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import it.csi.csi.wrapper.*;
import it.csi.csi.porte.HttpPDProxyLoader;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «papdCallBaseHandlerClassName()»{


	@Override
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		try {
			it.csi.iride2.policy.interfaces.PolicyEnforcerBaseService pd = 
				getPD();
			
			/// valore degli input slot
		«FOREACH this.paramBindings AS currPB-»
		«LET currPB.slot AS currIn-»
			«map2JavaTypeSDRelative(currIn.type)» slot_«currIn.name»  = 
			(«map2JavaTypeSDRelative(currIn.type)»)DataSlotHelper.getDataSlotValue("«getDataSlotAttrName(currIn)»",ps);
			
		«ENDLET-»
		«ENDFOREACH-»
			
			// binding dei parametri e richiamo del servizio 
			it.csi.iride2.policy.entity.Identita result = pd.identificaUserPassword(
			«FOREACH this.operation.params AS currParam SEPARATOR ","-»
			«"slot_"+this.paramBindings.select(pb|pb.param==currParam).first().slot.name»
			«ENDFOREACH-»
			);
			
			«IF this.operation.returnType!=null»
			/// inserimento risultato nello slot apposito
			DataSlotHelper.setDataSlotValue("«getDataSlotAttrName(this.outputSlot)»", result, ps);
			«ENDIF»
			
			
			
		} catch (Exception e) {
			// TODO Auto-generated catch block
			System.out.println("ERRORE richiamo (...TODO GESTIRE MEGLIO....) "+e);
			e.printStackTrace();
		}
	}
	
	«IF !this.serviceConnector.useRegistry-»
	private static «fullQualifiedServiceInterfaceName(this.serviceConnector.serviceDef, model)»
		cachedPD = null;
	«ENDIF-»
	
	protected «fullQualifiedServiceInterfaceName(this.serviceConnector.serviceDef, model)» getPD() throws ConfigException{
	«IF this.serviceConnector.useRegistry-»
		java.util.Properties selectorProps = new java.util.Properties();
		java.io.InputStream localPD = this.getClass().getResourceAsStream(localPDRes);
		«fullQualifiedServiceInterfaceName(this.serviceConnector.serviceDef, model)» tempPd =
			(«fullQualifiedServiceInterfaceName(this.serviceConnector.serviceDef, model)»)
				HttpPDProxyLoader.loadProxy(selectorRes, localPD);
		return tempPd;
	«ELSE-»
		if (cachedPD != null)
			return cachedPD;
		else{
			java.io.InputStream localPD = this.getClass().getResourceAsStream(localPDRes);
		
			it.csi.csi.porte.InfoPortaDelegata infoPD;
			«fullQualifiedServiceInterfaceName(this.serviceConnector.serviceDef, model)» tempPd=null;
			try {
				infoPD = it.csi.csi.util.xml.PDConfigReader.read(localPD);
				tempPd = («fullQualifiedServiceInterfaceName(this.serviceConnector.serviceDef, model)») it.csi.csi.porte.proxy.PDProxy.newInstance(infoPD);
			} catch (Exception e) {
				throw new ConfigException("Errore nella lettura della configurazione da "+localPDRes,e);
			}
			return tempPd;
		}
	«ENDIF-»
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR WSCall»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «wsCallBaseHandlerClassName()»{
	@Override
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		// TODO Auto-generated method stub
		
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR CustomTransformation»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «customTransformBaseHandlerClassName()»{

	
	public Object getTransformedObject(Map<String, Object> inputs){
		
		«map2JavaTypeSDRelative(output.type)» outVal = 
		 («map2JavaTypeSDRelative(output.type)»)(inputs.get(_outputSlotName));
		
		/// valore degli input slot
		«FOREACH input AS currIn-»
		«map2JavaTypeSDRelative(currIn.type)» slot_«currIn.name»  = 
			(«map2JavaTypeSDRelative(currIn.type)»)inputs.get("«getDataSlotAttrName(currIn)»");
		«ENDFOREACH-»
		
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"customTXLogic")»
		/// inserire qui la logica di trasformazione
		«ENDPROTECT»
		return outVal;
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR DeclarativeTransformation»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «declTransformBaseHandlerClassName()»{

	public «specificHandlerClassName()»(String inSlotNames[],
			Class inSlotTypes[], String outSlotName, Class outSlotType,
			boolean initOutSlot) {
			super(inSlotNames, inSlotTypes, outSlotName, outSlotType, initOutSlot);
	}

	public Object getTransformedObject(Map<String, Object> inputs){
		
		///// TODO
		return null;
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR ForEach»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «forEachBaseHandlerClassName()»{
	
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR EndLoop»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «endLoopBaseHandlerClassName()»{
	@Override
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		// TODO Auto-generated method stub
		
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR CheckCondition»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

public class «specificHandlerClassName()» extends «checkCondBaseHandlerClassName()»{
	@Override
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		// TODO Auto-generated method stub
		
	}
}
«ENDFILE»
«ENDDEFINE»


«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR UserDefinedOpNode»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;
import com.opensymphony.workflow.FunctionProvider;

import «baseHandlersPkg(model)».*;

«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"extraImport")»
// inserire qui eventuali import aggiuntive
«ENDPROTECT»

public class «specificHandlerClassName()» implements FunctionProvider{
	public void execute(Map transientVars, Map args, PropertySet ps)	throws WorkflowException {
		
		this.initFunctionHandler(transientVars,args,ps);
		
		this.eseguiFunctionHandler(transientVars,args,ps);
		
		this.releaseFunctionHandler(transientVars,args,ps);
	}

		
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"init")»
		«ENDPROTECT»
		
	}
	
    private void releaseFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
    	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"release")»
		«ENDPROTECT»
	}
    
    
	public void eseguiFunctionHandler(Map transientVars, Map args, PropertySet ps) throws  WorkflowException{
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"exec")»
		«ENDPROTECT»
	}
	
	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"extraMethods")»
	////// inserire qui eventuali metodi di supporto
	«ENDPROTECT»
	
	}
«ENDFILE»
«ENDDEFINE»