«IMPORT servicegen»
«IMPORT servicedef»
«IMPORT typedef»
«IMPORT appresources»
«IMPORT svcorch»

«IMPORT template::javavalidator»

«EXTENSION template::ServicegenExtensions»
«EXTENSION template::flowmodel::FlowModelExtensions»

«DEFINE baseHandlers FOR SOABEModel»
	«EXPAND dataSlotHelper FOR this»
 
	«EXPAND startNodeBaseHandler FOR this»
	«EXPAND stopNodeBaseHandler FOR this»
	«EXPAND papdCallBaseHandler FOR this»
	«EXPAND wsCallBaseHandler FOR this»
	«EXPAND forEachBaseHandler FOR this»
	«EXPAND endLoopBaseHandler FOR this»
	«EXPAND checkCondBaseHandler FOR this»
	«EXPAND customTransformBaseHandler FOR this»
	«EXPAND declTransformBaseHandler FOR this»
	
	«EXPAND forEachConditionClass FOR this»
	«EXPAND lastConditionSatisfiedClass FOR this»
	«EXPAND exceptionRaisedConditionClass FOR this»
«ENDDEFINE»

«DEFINE dataSlotHelper FOR SOABEModel»
«FILE dataSlotHelperFile()»package «baseHandlersPkg()»;

import java.lang.reflect.Array;
import com.opensymphony.module.propertyset.PropertySet;

/**
 * Classe di utilita' per la gestione dei data-slot all'interno del contesto di esecuzione 
 * di osworkflow.
 * @generated
 */
public class DataSlotHelper {

/**
 * Nome dello slot implicito utilizzato di default dagli handler per inserire l'ultima
 * eccezione occorsa.
 * @generated 
 */
public final static String LAST_ERROR_SLOT_NAME = "_lastError";

/**
 * Nome dello slot implicito utilizzato di default dagli handler per inserire l'ultima
 * condizione valutata.
 * @generated 
 */
public final static String LAST_CONDITION_VALUE_SLOT_NAME = "_lastConditionValue";

/**
 * @generated
 */
public static Exception getLastError(PropertySet ps){
	return (Exception)(getDataSlotValue(LAST_ERROR_SLOT_NAME, ps));
}

/**
 * @generated
 */
public static void setLastError(Exception exc, PropertySet ps){
	DataSlotHelper.setDataSlotValue(LAST_ERROR_SLOT_NAME, exc, ps);
}

/**
 * @generated
 */
public static Boolean getLastConditionValue(PropertySet ps){
	return (Boolean)(getDataSlotValue(LAST_CONDITION_VALUE_SLOT_NAME, ps));
}

/**
 * @generated
 */
public static void setLastConditionValue(Boolean condVal, PropertySet ps){
	DataSlotHelper.setDataSlotValue(LAST_CONDITION_VALUE_SLOT_NAME, condVal, ps);
}

/**
 * @generated
 */
public static Object getDataSlotValue(String name, PropertySet ps){
	return ps.getObject(name);
}

/**
 * @generated
 */
public static void setDataSlotValue(String name, Object val, PropertySet ps) {
		if (val!=null){
			ps.setObject(name, val);
		}
		else{
			ps.remove(name);
		}
}

/**
 * @generated
 */
public static Object initDataSlotValue(Class type){
	try {
		Object ris = type.newInstance();
		return ris;
	} catch (InstantiationException e) {
		throw new IllegalArgumentException("impossibile istanziare lo slot di tipo "+type+":"+e);
	} catch (IllegalAccessException e) {
		throw new IllegalArgumentException("impossibile istanziare lo slot di tipo "+type+":"+e);
	}
}

/**
 * @generated
 */
public static Class classForName(String clname) throws ClassNotFoundException{
	if (clname.endsWith("[]")){
		String compName = clname.substring(0,clname.length()-2);
		Object dummyArr = Array.newInstance(classForName(compName), 0);
		return dummyArr.getClass();
	}
	else{
		return Class.forName(clname);
	}
}
}

«ENDFILE»
«ENDDEFINE»

«DEFINE startNodeBaseHandler FOR SOABEModel»
«FILE startNodeBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.*;

import org.apache.log4j.Logger;
import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

/**
 * @generated
 */
public abstract class «startNodeBaseHandlerClassName()» implements FunctionProvider {
	
	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(this.codProdotto,this.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
	
	/**
 	 * @generated
 	 */
	public final static String INPUT_BINDING_PARAM_PREFIX = "input.binding.";
	
	/**
 	 * @generated
 	 */
	protected Map<String, String> _inputNameBindings;

	/**
 	 * @generated
 	 */
	public void execute(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {

		this.initFunctionHandler(transientVars, args, ps);

		this.eseguiFunctionHandler(transientVars, args, ps);

		this.releaseFunctionHandler(transientVars, args, ps);
	}

	/**
 	 * @generated
 	 */
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {
		«debugLog(startNodeBaseHandlerClassName(),"initFunctionHandler","START")»
		_inputNameBindings = new HashMap<String, String>();
		Iterator argnames_it = args.keySet().iterator();
		«debugLog(startNodeBaseHandlerClassName(),"initFunctionHandler","binding dei parametri di input")»
		while(argnames_it.hasNext()){
			String currArgName =(String)argnames_it.next();
			if (!currArgName.startsWith(INPUT_BINDING_PARAM_PREFIX))
				continue;
			
			String currArgVal = (String)args.get(currArgName);
			StringTokenizer stok = new StringTokenizer(currArgVal,"=");
			if (stok.countTokens()!=2)
				throw new WorkflowException("Errore nell'inizializzazione del workflow: il formato del parametro "+
						currArgName+" deve essere <nomeparametro>=<nomedataslot>, invece è "+currArgVal);
			else{
				String currInput=stok.nextToken();
				String currDS = stok.nextToken();
				_inputNameBindings.put(currInput, currDS);
				«debugLog(startNodeBaseHandlerClassName(),"initFunctionHandler","parametro:\"+currInput+\"->slot:\"+currDS+\"")»
			}
		}
		«debugLog(startNodeBaseHandlerClassName(),"initFunctionHandler","END")»
	}

	/**
 	 * @generated
 	 */
	private void releaseFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
	}

	/**
	 * Copia i valori dei parametri di input nei rispettivi DataSlot, 
	 * prendendo le informazioni di mapping da _inputNameBindings
	 * @param transientVars
	 * @param args
	 * @param ps
	 * @throws WorkflowException
	 * @generated
	 */
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		«debugLog(startNodeBaseHandlerClassName(),"eseguiFunctionHandler","START")»
		«debugLog(startNodeBaseHandlerClassName(),"eseguiFunctionHandler","inizializzazione slot di input")»
		Iterator<String> paramNames_it = _inputNameBindings.keySet().iterator();
		while (paramNames_it.hasNext()) {
			String currParamName = paramNames_it.next();
			String currDSName = _inputNameBindings.get(currParamName);
			DataSlotHelper.setDataSlotValue(currDSName, DataSlotHelper
					.getDataSlotValue("input.parameter."
							+ currParamName, ps), ps);
		}
		«debugLog(startNodeBaseHandlerClassName(),"eseguiFunctionHandler","START")»
	}

}
«ENDFILE»
«ENDDEFINE»

«DEFINE stopNodeBaseHandler FOR SOABEModel»
«FILE stopNodeBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;
import java.util.HashMap;
import java.util.Iterator;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.csi.wrapper.*;
import it.csi.svcflow.orchestrator.handler.*;

/**
 * @generated
 */
public class «stopNodeBaseHandlerClassName()» implements FunctionProvider {

	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(this.codProdotto,this.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
	
	/**
 	 * @generated
 	 */
	public final static String OUTPUT_BINDING_PARAM = "output.binding";
	
	/**
	 * @generated
	 */
	public final static String EXC_MAP_FROM_PARAM_PREFIX = "exception.mapping.from.";
	
	/**
	 * @generated
	 */
	public final static String EXC_MAP_TO_PARAM_PREFIX = "exception.mapping.to.";
	
	/**
	 * @generated
	 */
	public final static String EXC_MAP_MSG_PARAM_PREFIX = "exception.mapping.msg.";
	
	/**
 	 * @generated
 	 */
	public final static String RETURN_ATTRIBUTE_NAME = "result";

	/**
 	 * @generated
 	 */
	protected String _outputbindingName;

	/**
 	 * @generated
 	 */
	Map<Class,Class> excMap = null;
	
	/**
 	 * @generated
 	 */
	Map<Class,String> excMapMsg = null;
	
	/**
 	 * @generated
 	 */
	public void execute(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {

		this.initFunctionHandler(transientVars, args, ps);

		this.eseguiFunctionHandler(transientVars, args, ps);

		this.releaseFunctionHandler(transientVars, args, ps);
	}

	/**
 	 * @generated
 	 */
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {
		// se il parametro non e' valorizzato l'operazione viene considerata void
		_outputbindingName = (String) args.get(OUTPUT_BINDING_PARAM);
		// mapping eccezioni
		excMap = new HashMap<Class, Class>();
		excMapMsg = new HashMap<Class, String>();
		
		Iterator<String> key_it = args.keySet().iterator();
		while (key_it.hasNext()) {
			String currK = (String) key_it.next();
			if (currK.startsWith(EXC_MAP_FROM_PARAM_PREFIX)){
				String currFrom = (String)args.get(currK);
				String index = currK.substring(currK.lastIndexOf(".")+1);
				String currTo = (String)args.get(EXC_MAP_TO_PARAM_PREFIX+index);
				String currMsg = (String)args.get(EXC_MAP_MSG_PARAM_PREFIX+index);
				try{
					Class fromClass = Class.forName(currFrom);
					Class toClass = Class.forName(currTo);
					excMap.put(fromClass,toClass);
					excMapMsg.put(fromClass,currMsg);
				}
				catch(Exception e){
					«errorLog(stopNodeBaseHandlerClassName(),"initFunctionHandler","Errore nell'inizializzaizone dell handler:","e")»
					throw new WorkflowException("Errore nell'inizializzazione dell'handler:"+e);
				}
			}
		}
	}

	/**
 	 * @generated
 	 */
	private void releaseFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
	}

	/**
	 * Ricopia il valore del dataSlot di output nell'attributo "result", che
	 * sarà utilizzato nel metodo di orchestrazione come fonte del valore
	 * di ritorno (se _outputbindingname==null => void)
	 * @param transientVars
	 * @param args
	 * @param ps
	 * @throws WorkflowException
	 * @generated
	 */
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		«debugLog(stopNodeBaseHandlerClassName(),"eseguiFunctionHandler","START")»
		// verifica se c'e' un errore pendente
		if (DataSlotHelper.getLastError(ps)!=null){
			Exception e = DataSlotHelper.getLastError(ps);
			«debugLog(stopNodeBaseHandlerClassName(),"eseguiFunctionHandler","rilevato errore al termine dell'orchestrazione")»
			Class srcExcCl = e.getClass();
			Class trgExcCl = excMap.get(srcExcCl);
			if (trgExcCl != null) {
				/// mapping eccezione messaggio
				String msg = "";
				java.lang.reflect.Constructor exCtr;
				try {
					exCtr = trgExcCl.getConstructor(String.class, Throwable.class);
					CSIException eToThrow;
					try {
						eToThrow = (CSIException)exCtr.newInstance(msg, e);
						DataSlotHelper.setDataSlotValue(RETURN_ATTRIBUTE_NAME, eToThrow,
								ps);
					} catch (IllegalArgumentException e1) {
						// TODO Auto-generated catch block
						e1.printStackTrace();
						throw e1;
					} catch (InstantiationException e1) {
						// TODO Auto-generated catch block
						e1.printStackTrace();
						//throw e1;
					} catch (IllegalAccessException e1) {
						// TODO Auto-generated catch block
						e1.printStackTrace();
						//throw e1;
					} catch (java.lang.reflect.InvocationTargetException e1) {
						// TODO Auto-generated catch block
						e1.printStackTrace();
						//throw e1;
					}
				
					
				} catch (SecurityException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				} catch (NoSuchMethodException e1) {
					// TODO Auto-generated catch block
					e1.printStackTrace();
				}
				
			}
		}
		else if (_outputbindingName != null) {
			«debugLog(stopNodeBaseHandlerClassName(),"eseguiFunctionHandler","impostazione valore di ritorno dallo slot \"+_outputbindingName+\"")»
			Object retVal = DataSlotHelper
					.getDataSlotValue(_outputbindingName, ps);
			if (retVal != null)
				DataSlotHelper.setDataSlotValue(RETURN_ATTRIBUTE_NAME, retVal, ps);
		}
		«debugLog(stopNodeBaseHandlerClassName(),"eseguiFunctionHandler","END")»
	}

}
«ENDFILE»
«ENDDEFINE»

«DEFINE papdCallBaseHandler FOR SOABEModel»
«FILE papdCallBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

/**
 * @generated
 */
public abstract class «papdCallBaseHandlerClassName()» implements FunctionProvider {
	
	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(this.codProdotto,this.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
	
	/**
 	 * @generated
 	 */
	protected String selectorRes=null;
	
	/**
 	 * @generated
 	 */
	protected String localPDRes=null;
	
	/**
 	 * @generated
 	 */
	public final static String SELECTORPD_PARAM="selectorPD";
	
	/**
 	 * @generated
 	 */
	public final static String SERVICEPD_PARAM="servicePD";
	
	/**
 	 * @generated
 	 */
	public void execute(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {

		this.initFunctionHandler(transientVars, args, ps);

		this.eseguiFunctionHandler(transientVars, args, ps);

		this.releaseFunctionHandler(transientVars, args, ps);
	}

	/**
 	 * @generated
 	 */
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {
		«debugLog(papdCallBaseHandlerClassName(),"initFunctionHandler","START")»
		selectorRes = (String)args.get(SELECTORPD_PARAM);
		if (selectorRes==null || selectorRes.length()==0){
			throw new WorkflowException("Errore nella inizializzazione dell' handler PDPACall: "+
					"occorre configurare il percorso del file del selettore tramite il "+
					"parametro "+SELECTORPD_PARAM);
		}
		else
			selectorRes="/"+selectorRes;
			
		localPDRes = (String)args.get(SERVICEPD_PARAM);
		if (localPDRes==null || localPDRes.length()==0){
			throw new WorkflowException("Errore nella inizializzazione dell' handler PDPACall: "+
					"occorre configurare il percorso del file della PD Locale tramite il "+
					"parametro "+SERVICEPD_PARAM);
		}
		else
			localPDRes = "/"+localPDRes;
		«debugLog(papdCallBaseHandlerClassName(),"initFunctionHandler","selector:\"+selectorRes+\"")»
		«debugLog(papdCallBaseHandlerClassName(),"initFunctionHandler","localPD:\"+localPDRes+\"")»
		// reset dello slot destinato a contenere un eventuale errore
		DataSlotHelper.setLastError(null, ps);
		«debugLog(papdCallBaseHandlerClassName(),"initFunctionHandler","END")»
	}

	/**
 	 * @generated
 	 */
	private void releaseFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
	}

	/**
 	 * @generated
 	 */
	public abstract void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException;
	
}

«ENDFILE»
«ENDDEFINE»

«DEFINE wsCallBaseHandler FOR SOABEModel»
«FILE wsCallBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

/**
 * @generated
 */
public abstract class «wsCallBaseHandlerClassName()» implements FunctionProvider {

    /**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(this.codProdotto,this.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
   
	/**
 	 * @generated
 	 */
    public void execute(Map transientVars, Map args, PropertySet ps)	throws WorkflowException {
		
		this.initFunctionHandler(transientVars,args,ps);
		
		this.eseguiFunctionHandler(transientVars,args,ps);
		
		this.releaseFunctionHandler(transientVars,args,ps);
	}

	/**
 	 * @generated
 	 */	
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
		
		
	}
	
	/**
 	 * @generated
 	 */
    private void releaseFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
	}
    
    /**
 	 * @generated
 	 */
	public abstract void eseguiFunctionHandler(Map transientVars, Map args, PropertySet ps) throws  WorkflowException;
	
}

«ENDFILE»
«ENDDEFINE»

«DEFINE forEachBaseHandler FOR SOABEModel»
«FILE forEachBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.*;
import org.apache.log4j.Logger;
import java.lang.reflect.Array;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

/**
 * @generated
 */
public class «forEachBaseHandlerClassName()» implements FunctionProvider {

	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(this.codProdotto,this.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
	
	/**
 	 * @generated
 	 */
	public final static String COLLECTION_SLOT_NAME_PARAM_NAME = "collection.slot.name";
	
	/**
 	 * @generated
 	 */
	public final static String ITEM_SLOT_NAME_PARAM_NAME = "item.slot.name";
	
	/**
 	 * @generated
 	 */
	public final static String ITERATOR_SLOT_NAME_SUFFIX = "_for_each_iterator";
	
	/**
 	 * @generated
 	 */
	public final static String MORE_ELEMENTS_SLOT_NAME_SUFFIX = "_has_more_elements";
	
	/**
 	 * @generated
 	 */
	protected String _collectionSlotName;
	
	/**
 	 * @generated
 	 */
	protected String _itemSlotName;
	
	/**
 	 * @generated
 	 */
	public void execute(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {

		this.initFunctionHandler(transientVars, args, ps);

		this.eseguiFunctionHandler(transientVars, args, ps);

		this.releaseFunctionHandler(transientVars, args, ps);
	}

	/**
 	 * @generated
 	 */
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {
		«debugLog(forEachBaseHandlerClassName(),"initFunctionHandler","START")»
		String collSN = (String)args.get(COLLECTION_SLOT_NAME_PARAM_NAME);
		String itemSN = (String)args.get(ITEM_SLOT_NAME_PARAM_NAME);
		if (collSN==null || collSN.length()==0)
			throw new WorkflowException("Errore nell'inizializzazione dell handler ForEach: non è stato impostato il parametro "+COLLECTION_SLOT_NAME_PARAM_NAME);
		if (itemSN==null || itemSN.length()==0)
			throw new WorkflowException("Errore nell'inizializzazione dell handler ForEach: non è stato impostato il parametro "+ITEM_SLOT_NAME_PARAM_NAME);
		//
		_collectionSlotName=collSN.trim();
		_itemSlotName=itemSN.trim();
		«debugLog(forEachBaseHandlerClassName(),"initFunctionHandler","collection slot:\"+_collectionSlotName+\"")»
		«debugLog(forEachBaseHandlerClassName(),"initFunctionHandler","item slot:\"+_itemSlotName+\"")»
		«debugLog(forEachBaseHandlerClassName(),"initFunctionHandler","END")»
	}

	/**
 	 * @generated
 	 */
	private void releaseFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
	}

	/**
 	 * @generated
 	 */
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException{
		«debugLog(forEachBaseHandlerClassName(),"eseguiFunctionHandler","START")»
		// e' il primo giro?
		Iterator iterator = (Iterator)DataSlotHelper.getDataSlotValue(_collectionSlotName+ITERATOR_SLOT_NAME_SUFFIX, ps);
		if (iterator==null){
			«debugLog(forEachBaseHandlerClassName(),"eseguiFunctionHandler","primo giro")»
			// inizializza il loop
			Object collectionVal = DataSlotHelper.getDataSlotValue(_collectionSlotName, ps);
			if(collectionVal == null)
				throw new WorkflowException("Errore nel loop: collezione nulla");
					
			// la collection dovrebbe essere di tipo array (garantito da check) 
			if (!collectionVal.getClass().isArray())
				throw new WorkflowException("Errore durante iniziualizzazione ForEach: il tipo della collection "+_collectionSlotName+
						" non è un typed array ma "+collectionVal.getClass());
			else{
				// ok vai
				ArrayList coll = new ArrayList();
				if (collectionVal!=null){
					int sz =Array.getLength(collectionVal);
					«debugLog(forEachBaseHandlerClassName(),"eseguiFunctionHandler","la collezione contiene:\"+sz+\"elementi ")»
					for (Object curr : (Object[])collectionVal) {
						coll.add(curr);
					}
				}
				iterator = coll.iterator();
				DataSlotHelper.setDataSlotValue(_collectionSlotName+ITERATOR_SLOT_NAME_SUFFIX, iterator, ps);
			}
		}
		
		// in ogni caso verifica se ci sono ancora elementi e carica il prossimo
		if (iterator.hasNext()){
			«debugLog(forEachBaseHandlerClassName(),"eseguiFunctionHandler","caricamento prossimo elemento nello slot \"+_itemSlotName+\"")»
			Object next = iterator.next();
			// rende disponibile il prossimo elemento nello slot item
			DataSlotHelper.setDataSlotValue(_itemSlotName, next, ps);
			// imposta al condizione di loop a true
			DataSlotHelper.setDataSlotValue(_collectionSlotName+MORE_ELEMENTS_SLOT_NAME_SUFFIX, Boolean.TRUE, ps);
		}
		else{
			«debugLog(forEachBaseHandlerClassName(),"eseguiFunctionHandler","non ci sono piu' elementi su cui iterare")»
			// rimuove dal property set l'attributo di iterazione
			DataSlotHelper.setDataSlotValue(_itemSlotName, null, ps);
			DataSlotHelper.setDataSlotValue(_collectionSlotName+ITERATOR_SLOT_NAME_SUFFIX, null, ps);
			DataSlotHelper.setDataSlotValue(_collectionSlotName+MORE_ELEMENTS_SLOT_NAME_SUFFIX, null, ps);
			// imposta la condizione di loop a false
			DataSlotHelper.setDataSlotValue(_collectionSlotName+MORE_ELEMENTS_SLOT_NAME_SUFFIX, Boolean.FALSE, ps);
		}
	}
}

«ENDFILE»
«ENDDEFINE»


«DEFINE endLoopBaseHandler FOR SOABEModel»
«FILE endLoopBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

/**
 * @generated
 */
public abstract class «endLoopBaseHandlerClassName()» implements FunctionProvider {

   
	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(this.codProdotto,this.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
	
	/**
 	 * @generated
 	 */
    public void execute(Map transientVars, Map args, PropertySet ps)	throws WorkflowException {
		
		this.initFunctionHandler(transientVars,args,ps);
		
		this.eseguiFunctionHandler(transientVars,args,ps);
		
		this.releaseFunctionHandler(transientVars,args,ps);
	}

	/**
 	 * @generated
 	 */
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
		
	}
	
	/**
 	 * @generated
 	 */
    private void releaseFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
	}
    
    /**
 	 * @generated
 	 */
	public abstract void eseguiFunctionHandler(Map transientVars, Map args, PropertySet ps) throws  WorkflowException;
	
}

«ENDFILE»
«ENDDEFINE»


«DEFINE checkCondBaseHandler FOR SOABEModel»
«FILE checkCondBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

/**
 * @generated
 */
public abstract class «checkCondBaseHandlerClassName()» implements FunctionProvider {

	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(this.codProdotto,this.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
	
	/**
 	 * @generated
 	 */
   	public static final String LAST_CONDITION_VALUE_SLOT = "_lastConditionValue";

    /**
 	 * @generated
 	 */
    public void execute(Map transientVars, Map args, PropertySet ps)	throws WorkflowException {
		
		this.initFunctionHandler(transientVars,args,ps);
		
		this.eseguiFunctionHandler(transientVars,args,ps);
		
		this.releaseFunctionHandler(transientVars,args,ps);
	}

	/**
 	 * @generated
 	 */
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
		
	}
	
	/**
 	 * @generated
 	 */
    private void releaseFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
	}
    
	
	/**
 	 * @generated
 	 */
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException{
		«debugLog(checkCondBaseHandlerClassName(),"eseguiFunctionHandler","START")»
		DataSlotHelper.setDataSlotValue(LAST_CONDITION_VALUE_SLOT, null, ps);
		Boolean condVal = evalCondition(ps);
		DataSlotHelper.setDataSlotValue(LAST_CONDITION_VALUE_SLOT, condVal, ps);
		«debugLog(checkCondBaseHandlerClassName(),"eseguiFunctionHandler","valore condizione:\"+condVal+\"")»
		«debugLog(checkCondBaseHandlerClassName(),"eseguiFunctionHandler","END")»
	}

	/**
	 * Deve essere implementata a seconda della condizione da verificare
	 * @generated
	 */
	public abstract boolean evalCondition(PropertySet ps) throws WorkflowException;
	
}

«ENDFILE»
«ENDDEFINE»

«DEFINE customTransformBaseHandler FOR SOABEModel»
«FILE customTransformBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.*;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

/**
 * Classe base per la gestione delle trasformazioni custom (hand written).
 * @generated 
 */
public abstract class «customTransformBaseHandlerClassName()» implements FunctionProvider {

	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(this.codProdotto,this.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
	
	/**
 	 * @generated
 	 */
	public static final String INPUT_SLOT_NAME_PARAM_PREFIX = "input.slot.name.";
	
	/**
 	 * @generated
 	 */
	public static final String INPUT_SLOT_CLASS_PARAM_PREFIX = "input.slot.class.";
	
	/**
 	 * @generated
 	 */
	public static final String OUTPUT_SLOT_NAME_PARAM = "output.slot.name";
	
	/**
 	 * @generated
 	 */
	public static final String OUTPUT_SLOT_CLASS_PARAM = "output.slot.class";
	
	/**
 	 * @generated
 	 */
	public static final String INIT_OUTPUT_PARAM = "output.slot.init";

	/**
 	 * @generated
 	 */
	protected ArrayList<String> _inputSlotNames;
	
		
	/**
 	 * @generated
 	 */
	protected String _outputSlotName;
	
	
	/**
 	 * @generated
 	 */
	protected boolean _initOutSlot = false;

	/**
 	 * @generated
 	 */
	public void execute(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {

		this.initFunctionHandler(transientVars, args, ps);

		this.eseguiFunctionHandler(transientVars, args, ps);

		this.releaseFunctionHandler(transientVars, args, ps);
	}

	/**
 	 * @generated
 	 */
	protected void initFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		«debugLog(customTransformBaseHandlerClassName(),"initFunctionHandler","START")»
		// input slots
		_inputSlotNames = new ArrayList<String>();
		
		Iterator<String> argnames_it = args.keySet().iterator();
		while(argnames_it.hasNext()){
			String currArgname = argnames_it.next();
			String currArgVal = null;
			if (currArgname.startsWith(INPUT_SLOT_NAME_PARAM_PREFIX)){
				currArgVal = (String)args.get(currArgname);
				_inputSlotNames.add(currArgVal);
				«debugLog(customTransformBaseHandlerClassName(),"initFunctionHandler","input slot::\"+currArgVal+\"")»
			}
			else if (currArgname.startsWith(INPUT_SLOT_CLASS_PARAM_PREFIX)){
				currArgVal = (String)args.get(currArgname);
				
			}
		}
		// out slot
		String outSlotName = (String)args.get(OUTPUT_SLOT_NAME_PARAM);
		if (outSlotName!=null){
			_outputSlotName=outSlotName.trim();
			«debugLog(customTransformBaseHandlerClassName(),"initFunctionHandler","output slot:\"+outSlotName+\"")»
			String outClassName = (String)args.get(OUTPUT_SLOT_CLASS_PARAM);
			
		}
		else 
			throw new WorkflowException("Errore interno nell'inizializzazione dell'hanlder: output slot nullo");
		«debugLog(customTransformBaseHandlerClassName(),"eseguiFunctionHandler","END")»
	}

	/**
 	 * @generated
 	 */
	protected void releaseFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
	}

	/**
 	 * @generated
 	 */
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		«debugLog(customTransformBaseHandlerClassName(),"eseguiFunctionHandler","START")»
		«debugLog(customTransformBaseHandlerClassName(),"eseguiFunctionHandler","lettura degli input della trasformazione dagli slot")»
		Map<String, Object> inputs = new HashMap<String, Object>();
		
		for (int i = 0; i < _inputSlotNames.size(); i++) {
			String currInSlotName = _inputSlotNames.get(i);
			«debugLog(customTransformBaseHandlerClassName(),"eseguiFunctionHandler","input:\"+currInSlotName+\"")»
			Object currInSlotVal = ps.getObject(currInSlotName);
			inputs.put(currInSlotName, currInSlotVal);
		}
		Object outVal = getTransformedObject(inputs);
		DataSlotHelper.setDataSlotValue(_outputSlotName, outVal, ps);
		«debugLog(customTransformBaseHandlerClassName(),"eseguiFunctionHandler","END")»
	}

	/**
	 * Questo metodo deve essere ridefinito nelle sottoclassi specifiche con la logica 
	 * di trasformazione vera e propria.
	 *  
	 * @param inValues mappa contenente i valori dei dataSlot di input. Per trasformazioni
	 * incrementali anche il dataSlot di output può essere un dataSlot di input.
	 * @return l'oggetto trasformato, che verrà rimpiazzato al valore eventualmente precedente
	 * nel context.
	 * @generated
	 */
	public abstract Object getTransformedObject(Map<String, Object> inValues);

}
«ENDFILE»
«ENDDEFINE»

«DEFINE declTransformBaseHandler FOR SOABEModel»
«FILE declTransformBaseHandlerFile()»package «baseHandlersPkg()»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.FunctionProvider;
import com.opensymphony.workflow.WorkflowException;

import it.csi.svcflow.orchestrator.handler.*;

/**
 * @generated
 */
public abstract class «declTransformBaseHandlerClassName()» extends «customTransformBaseHandlerClassName()» {
   
   	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(this.codProdotto,this.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
   	
	/**
 	 * @generated
 	 */
	public abstract Object getTransformedObject(Map<String, Object> inputs);
	
}

«ENDFILE»
«ENDDEFINE»

«DEFINE exceptionRaisedConditionClass FOR SOABEModel»
«FILE excRaisedConditionFile()»package «baseHandlersPkg()»;

import java.util.Map;
import java.util.StringTokenizer;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.Condition;
import com.opensymphony.workflow.WorkflowException;


/**
 * @generated
 */
public class «excRaisedConditionClassName()» implements Condition {

	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(this.codProdotto,this.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
	
	/**
 	 * @generated
 	 */
	public final static String HANDLED_EXCEPTIONS_PARAM_NAME = "handled.exceptions";

	
	/**
 	 * @generated
 	 */
	public boolean passesCondition(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {
		«debugLog(excRaisedConditionClassName(),"passesCondition","START")»
		String hndExcs = (String) args
				.get(HANDLED_EXCEPTIONS_PARAM_NAME);
		if (hndExcs == null)
			throw new WorkflowException(
					"errore nella configurazione della condizione di verifica eccezioni: occorre configurare "
							+ "il parametro "
							+ HANDLED_EXCEPTIONS_PARAM_NAME
							+ " valorizzandolo con la lista dei f.q.n delle eccezioni gestite, separate da ','.");

		
		Exception lastError = DataSlotHelper.getLastError(ps);
		if (lastError!=null){
			StringTokenizer strtok = new StringTokenizer(hndExcs, ",");
			while(strtok.hasMoreTokens()){
				String currExc = strtok.nextToken();
				if (currExc.equals(lastError.getClass().getName())){
					«debugLog(excRaisedConditionClassName(),"passesCondition","rilevata eccezione gestita:\"+currExc+\"")»
					«debugLog(excRaisedConditionClassName(),"passesCondition","END")»
					return true;
				}
			}
			// se arrivo qui non è stata trovata l'eccezione
			«debugLog(excRaisedConditionClassName(),"passesCondition","END")»
			return false;
		}
		else {
			«debugLog(excRaisedConditionClassName(),"eseguiFunctionHandler","END")»
			return false;
		}
	}
}
«ENDFILE»

«ENDDEFINE»

«DEFINE forEachConditionClass FOR SOABEModel»
«FILE forEachConditionFile()»package «baseHandlersPkg()»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.Condition;
import com.opensymphony.workflow.WorkflowException;


/**
 * @generated
 */
public class «forEachConditionClassName()» implements Condition{

	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(this.codProdotto,this.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
	
	/**
 	 * @generated
 	 */
	public final static String BRANCH_PARAM_NAME = "for.each.branch";
	
	/**
 	 * @generated
 	 */
	public final static String STAY="stay";
	
	/**
 	 * @generated
 	 */
	public final static String EXIT="exit";
	
	/**
 	 * @generated
 	 */
	public boolean passesCondition(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {
		«debugLog(forEachConditionClassName(),"passesCondition","START")»
		String collSN = (String)args.get(ForEachBaseHandler.COLLECTION_SLOT_NAME_PARAM_NAME);
		if (collSN==null)
			throw new WorkflowException("errore nella configurazione della condizione del for each: occorre configurare "+
					"il parametro "+ForEachBaseHandler.COLLECTION_SLOT_NAME_PARAM_NAME+ 
					" valorizzandolo coerentemente con il nodo for each corrispondente.");
		
		String branch = (String)args.get(BRANCH_PARAM_NAME);
		«debugLog(forEachConditionClassName(),"passesCondition","branch:\"+branch+\"")»
		if (branch == null || 
			(!branch.equals(STAY)&&!branch.equals(EXIT))
		){
			throw new WorkflowException("errore nella configurazione della condizione del for each: occorre configurare "+
					"il parametro "+BRANCH_PARAM_NAME+ 
					" valorizzandolo con '"+STAY+"' o '"+EXIT+"'");
		}
		Boolean continueFlag = (Boolean)DataSlotHelper.getDataSlotValue(collSN+ForEachBaseHandler.MORE_ELEMENTS_SLOT_NAME_SUFFIX, ps);
		if (continueFlag==null)
			continueFlag=Boolean.FALSE;
		if (branch.equals(STAY)){
			«debugLog(forEachConditionClassName(),"passesCondition","END")»
			return continueFlag.booleanValue();
		}
		else {
			«debugLog(forEachConditionClassName(),"passesCondition","END")»
			return !continueFlag.booleanValue();
		}
		
	}
}
«ENDFILE»
«ENDDEFINE»


«DEFINE lastConditionSatisfiedClass FOR SOABEModel»
«FILE lastConditionSatisfiedFile()»package «baseHandlersPkg()»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.Condition;
import com.opensymphony.workflow.WorkflowException;


/**
 * @generated
 */
public class «lastConditionSatisfiedClassName()» implements Condition{

	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(this.codProdotto,this.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
	
	/**
 	 * @generated
 	 */
	public boolean passesCondition(Map transientVars, Map args, PropertySet ps)
			throws WorkflowException {
		«debugLog(lastConditionSatisfiedClassName(),"passesCondition","START")»
		Boolean satisfiedFlag = (Boolean)DataSlotHelper.getLastConditionValue(ps);
		if (satisfiedFlag==null){
			«debugLog(lastConditionSatisfiedClassName(),"passesCondition","lastcondition flag non valorizzato: condizione non soddisfatta")»
			«debugLog(lastConditionSatisfiedClassName(),"passesCondition","END")»
			return false;
		}
		else {
			«debugLog(lastConditionSatisfiedClassName(),"passesCondition","lastcondition flag:\"+satisfiedFlag+\"")»
			«debugLog(lastConditionSatisfiedClassName(),"passesCondition","END")»
			return satisfiedFlag.booleanValue();
		}
		
	}
}
«ENDFILE»
«ENDDEFINE»

«REM»crea gli handler relativi ad una singola orchestrazione«ENDREM»
«DEFINE svcflowHandlerFiles(ServiceDef sd, SOABEModel model) FOR Operation»
«LET findOrchestrationForOperation(sd, model) AS currentOrchModel»
«IF currentOrchModel!=null»
	«EXPAND svcflowHandlers(sd, model) FOR currentOrchModel»
«ELSE»
«ERROR "Inconsistenza: impossibile trovare l'orchestrazione relativa al servizio "+sd.codServizio+", op: "+this.name»
«ENDIF»
«ENDLET»
«ENDDEFINE»

«DEFINE svcflowHandlers(ServiceDef sd, SOABEModel model) FOR Orchestration»
	«EXPAND svcflowHandler(this, sd, model) FOREACH this.nodes.nodes»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR Node»
«ERROR "Tipo di nodo non gestito"»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR StartNode»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

/**
 * @generated
 */
public class «specificHandlerClassName()» extends «startNodeBaseHandlerClassName()»{
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR StopNode»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

/**
 * @generated
 */
public class «specificHandlerClassName()» extends «stopNodeBaseHandlerClassName()»{
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR PAPDCall»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import it.csi.csi.wrapper.*;
import it.csi.csi.porte.HttpPDProxyLoader;

import «baseHandlersPkg(model)».*;

/**
 * @generated
 */
public class «specificHandlerClassName()» extends «papdCallBaseHandlerClassName()»{

	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(model.codProdotto,model.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
	
	/**
 	 * @generated
 	 */
	@Override
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		«debugLog(specificHandlerClassName(),"eseguiFunctionHandler","START")»
		try {
			«fullQualifiedServiceInterfaceName(this.serviceConnector.serviceDef, model)» pd = 
				getPD();
			
			/// valore degli input slot
			«debugLog(specificHandlerClassName(),"eseguiFunctionHandler","binding parametri")»
		«FOREACH this.paramBindings AS currPB-»
		«LET currPB.slot AS currIn-»
			«map2JavaTypeSDRelative(currIn.type)» slot_«currIn.name»  = 
			(«map2JavaTypeSDRelative(currIn.type)»)DataSlotHelper.getDataSlotValue("«getDataSlotAttrName(currIn)»",ps);
			
		«ENDLET-»
		«ENDFOREACH-»
			
			// binding dei parametri e richiamo del servizio 
			«debugLog(specificHandlerClassName(),"eseguiFunctionHandler","richiamo del metodo "+operation.name)»
			«IF this.operation.returnType!=null-»
			«map2JavaTypeSDRelative(this.operation.returnType)» result = pd.«operation.name»(
			«FOREACH this.operation.params AS currParam SEPARATOR ","-»
			«"slot_"+this.paramBindings.select(pb|pb.param==currParam).first().slot.name»
			«ENDFOREACH-»
			);
			«debugLog(specificHandlerClassName(),"eseguiFunctionHandler","richiamo ok")»
			/// inserimento risultato nello slot apposito
			«debugLog(specificHandlerClassName(),"eseguiFunctionHandler","inserimento del risultato nello slot "+getDataSlotAttrName(this.outputSlot))»
			DataSlotHelper.setDataSlotValue("«getDataSlotAttrName(this.outputSlot)»", result, ps);
			«ELSE-»
			// binding dei parametri e richiamo del servizio 
			«debugLog(specificHandlerClassName(),"eseguiFunctionHandler","richiamo del metodo "+operation.name)»
			pd.«operation.name»(
			«FOREACH this.operation.params AS currParam SEPARATOR ","-»
			«"slot_"+this.paramBindings.select(pb|pb.param==currParam).first().slot.name»
			«ENDFOREACH-»
			);
			«debugLog(specificHandlerClassName(),"eseguiFunctionHandler","richiamo ok")»
			«ENDIF-»
			
			
			
		} catch (Exception e) {
			DataSlotHelper.setLastError(e, ps);
			«debugLog(specificHandlerClassName(),"eseguiFunctionHandler","richiamo ko, inserimento eccezione \"+e+\" nell'apposito slot")»
			«errorLog(specificHandlerClassName(),"eseguiFunctionHandler","richiamo ko, inserimento eccezione \"+e+\" nell'apposito slot","e")»
		}
	}
	
	«IF !this.serviceConnector.useRegistry-»
	private static «fullQualifiedServiceInterfaceName(this.serviceConnector.serviceDef, model)»
		cachedPD = null;
	«ENDIF-»
	
	/**
 	 * @generated
 	 */
	protected «fullQualifiedServiceInterfaceName(this.serviceConnector.serviceDef, model)» getPD() throws ConfigException{
		«debugLog(specificHandlerClassName(),"getPD","START")»
	«IF this.serviceConnector.useRegistry-»
		«debugLog(specificHandlerClassName(),"getPD","reperimento PD da registry")»
		«debugLog(specificHandlerClassName(),"getPD","-selector:\"+selectorRes+\"")»
		«debugLog(specificHandlerClassName(),"getPD","-localPD:\"+localPDRes+\"")»
		java.util.Properties selectorProps = new java.util.Properties();
		java.io.InputStream localPD = this.getClass().getResourceAsStream(localPDRes);
		«fullQualifiedServiceInterfaceName(this.serviceConnector.serviceDef, model)» tempPd =
			(«fullQualifiedServiceInterfaceName(this.serviceConnector.serviceDef, model)»)
				HttpPDProxyLoader.loadProxy(selectorRes, localPD);
		«debugLog(specificHandlerClassName(),"getPD","END")»
		return tempPd;
	«ELSE-»
		«debugLog(specificHandlerClassName(),"getPD","reperimento PD da risorsa locale:\"+localPDRes+\"")»
		if (cachedPD != null){
			«debugLog(specificHandlerClassName(),"getPD","PD gia' presente in cache")»
			«debugLog(specificHandlerClassName(),"getPD","END")»
			return cachedPD;
		}
		else{
			«debugLog(specificHandlerClassName(),"getPD","PD non presente in cache")»
			java.io.InputStream localPD = this.getClass().getResourceAsStream(localPDRes);
		
			it.csi.csi.porte.InfoPortaDelegata infoPD;
			«fullQualifiedServiceInterfaceName(this.serviceConnector.serviceDef, model)» tempPd=null;
			try {
				infoPD = it.csi.csi.util.xml.PDConfigReader.read(localPD);
				tempPd = («fullQualifiedServiceInterfaceName(this.serviceConnector.serviceDef, model)») it.csi.csi.porte.proxy.PDProxy.newInstance(infoPD);
			} catch (Exception e) {
				throw new ConfigException("Errore nella lettura della configurazione da "+localPDRes,e);
			}
			«debugLog(specificHandlerClassName(),"getPD","END")»
			return tempPd;
		}
	«ENDIF-»
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR WSCall»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

/**
 * @generated
 */
public class «specificHandlerClassName()» extends «wsCallBaseHandlerClassName()»{
	
	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(model.codProdotto,model.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
	
	/**
 	 * @generated
 	 */
	@Override
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		// TODO Auto-generated method stub
		
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR CustomTransformation»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"customImport")»
/// inserire qui eventuali import aggiuntive.
«ENDPROTECT»

/**
 * @generated
 */
public class «specificHandlerClassName()» extends «customTransformBaseHandlerClassName()»{

	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(model.codProdotto,model.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
	
	public Object getTransformedObject(Map<String, Object> inputs){
		«debugLog(specificHandlerClassName(),"getTransformedObject","START")»		
		«map2JavaTypeSDRelative(output.type)» outVal = 
		 («map2JavaTypeSDRelative(output.type)»)(inputs.get(_outputSlotName));
		
		/// valore degli input slot
		«FOREACH input AS currIn-»
		«map2JavaTypeSDRelative(currIn.type)» slot_«currIn.name»  = 
			(«map2JavaTypeSDRelative(currIn.type)»)inputs.get("«getDataSlotAttrName(currIn)»");
		«ENDFOREACH-»
		
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"customTXLogic")»
		/// inserire qui la logica di trasformazione
		«ENDPROTECT»
		«debugLog(specificHandlerClassName(),"getTransformedObject","END")»
		return outVal;
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR DeclarativeTransformation»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;


/**
 * @generated
 */
public class «specificHandlerClassName()» extends «declTransformBaseHandlerClassName()»{

	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(model.codProdotto,model.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
	
	/**
 	 * @generated
 	 */
	public «specificHandlerClassName()»(String inSlotNames[],
			Class inSlotTypes[], String outSlotName, Class outSlotType,
			boolean initOutSlot) {
			super(inSlotNames, inSlotTypes, outSlotName, outSlotType, initOutSlot);
	}

	/**
 	 * @generated
 	 */
	public Object getTransformedObject(Map<String, Object> inputs){
		
		///// TODO
		return null;
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR ForEach»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

/**
 * @generated
 */
public class «specificHandlerClassName()» extends «forEachBaseHandlerClassName()»{
	
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR EndLoop»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

/**
 * @generated
 */
public class «specificHandlerClassName()» extends «endLoopBaseHandlerClassName()»{
	/**
 	 * @generated
 	 */
	@Override
	public void eseguiFunctionHandler(Map transientVars, Map args,
			PropertySet ps) throws WorkflowException {
		«debugLog(specificHandlerClassName(),"eseguiFunctionHandler","START")»
		«debugLog(specificHandlerClassName(),"eseguiFunctionHandler","END")»
	}
}
«ENDFILE»
«ENDDEFINE»

«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR CheckCondition»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;

import «baseHandlersPkg(model)».*;

«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"customImport")»
/// inserire qui eventuali import aggiuntive.
«ENDPROTECT»

/**
 * @generated
 */
public class «specificHandlerClassName()» extends «checkCondBaseHandlerClassName()»{
	
	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(model.codProdotto,model.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
	
	public boolean evalCondition(PropertySet ps) throws WorkflowException {
		«debugLog(specificHandlerClassName(),"evalCondition","START")»
		try{
			/// valore degli input slot
		
		
		«FOREACH input AS currIn-»
			«map2JavaTypeSDRelative(currIn.type)» slot_«currIn.name»  = 
				(«map2JavaTypeSDRelative(currIn.type)»)DataSlotHelper.getDataSlotValue("«getDataSlotAttrName(currIn)»", ps);
		«ENDFOREACH-»
		
		
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID("CHKLogic"+orch.operation.name+name)»//
			/// inserire qui la logica del check. 
			/// verra' preservata per successive rigenerazioni
			return true;		
		«ENDPROTECT»
		}
		catch(Throwable e){
			«errorLog(specificHandlerClassName(),"evalCondition","errore durante l'esecuzione del check", "e")»
			throw new WorkflowException("Errore durante l'esecuzione del check:"+e);
		}
		finally{
			«debugLog(specificHandlerClassName(),"eseguiFunctionHandler","END")»
		}
	}
}
«ENDFILE»
«ENDDEFINE»


«DEFINE svcflowHandler(Orchestration orch, ServiceDef sd, SOABEModel model) FOR UserDefinedOpNode»
«FILE this.fullSpecificHandlerFile(orch.operation,model)»package «specificHandlersPkg(orch.operation,model)»;

import java.util.Map;
import org.apache.log4j.Logger;

import com.opensymphony.module.propertyset.PropertySet;
import com.opensymphony.workflow.WorkflowException;
import com.opensymphony.workflow.FunctionProvider;

import «baseHandlersPkg(model)».*;

«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"extraImport")»
// inserire qui eventuali import aggiuntive
«ENDPROTECT»

/**
 * @generated
 */
public class «specificHandlerClassName()» implements FunctionProvider{
	
	/**
	 * @generated
	 */
	public static final String LOGGER_PREFIX = "«getLoggerPrefixForComponent(model.codProdotto,model.codComponente)»";
	
	/**
	 * @generated
	 */
	protected Logger getLogger(String subsystem){
	  if (subsystem!=null)
	  	return Logger.getLogger(LOGGER_PREFIX+"."+subsystem);
	  else
	    return Logger.getLogger(LOGGER_PREFIX);
	}
	
	/**
 	 * @generated
 	 */
	public void execute(Map transientVars, Map args, PropertySet ps)	throws WorkflowException {
		
		this.initFunctionHandler(transientVars,args,ps);
		
		this.eseguiFunctionHandler(transientVars,args,ps);
		
		this.releaseFunctionHandler(transientVars,args,ps);
	}

		
	private void initFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
		«debugLog(specificHandlerClassName(),"initFunctionHandler","START")»
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"init")»
		«ENDPROTECT»
		«debugLog(specificHandlerClassName(),"eseguiFunctionHandler","END")»
	}
	
    private void releaseFunctionHandler(Map transientVars, Map args, PropertySet ps) throws WorkflowException {
    	«debugLog(specificHandlerClassName(),"releaseFunctionHandler","START")»
    	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"release")»
		«ENDPROTECT»
		«debugLog(specificHandlerClassName(),"releaseFunctionHandler","END")»
	}
    
    
	public void eseguiFunctionHandler(Map transientVars, Map args, PropertySet ps) throws  WorkflowException{
		«debugLog(specificHandlerClassName(),"eseguiFunctionHandler","START")»
		«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"exec")»
		«ENDPROTECT»
		«debugLog(specificHandlerClassName(),"eseguiFunctionHandler","END")»
	}
	
	«PROTECT CSTART '/*' CEND '*/' ID getRegionUID(sd.codServizio+orch.operation.name+this.name+"extraMethods")»
	////// inserire qui eventuali metodi di supporto
	«ENDPROTECT»
	
	}
«ENDFILE»
«ENDDEFINE»
