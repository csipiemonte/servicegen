«IMPORT servicegen»
«IMPORT servicedef»
«IMPORT typedef»

«EXTENSION template::ServicegenExtensions»

«DEFINE defpafile (String svn_project_dir, servicegen::SOABEModel model, servicedef::ServiceDef serviceDef) FOR servicedef::EJBPABinding»
«FILE svn_project_dir+"/"+paConfigDir(model.codComponente,serviceDef)+"/"+paDefFileName(serviceDef)»<porta-applicativa name="«this.paSymName(model.codProdotto, model.codComponente,serviceDef)»"
	public-interface-class="«serviceDef.fullQualifiedServiceInterfaceName(model.codProdotto,model.codComponente)»">

	<listener class="it.csi.csi.porte.ejb20.PortaApplicativaEJB" listening-url="**NOT USED IN THIS BINDING TYPE**" />

	<adapter class="it.csi.csi.wrapper.StatelessEJBAdapter">
		<properties>
			<!--<property name="jndi-name"
				value="«fullServiceJndiName(model.codProdotto, model.codComponente, serviceDef)»" />-->
			<property name="jndi-name"
				value="java:comp/env/«getServiceBeanName(serviceDef)»" />				
			<property name="home-class"
				value="«fullQualifiedServiceLocalHomeInterfaceName(model.codProdotto,model.codComponente,serviceDef)»" />
			<property name="local-class"
				value="«fullQualifiedServiceLocalInterfaceName(model.codProdotto,model.codComponente,serviceDef)»" />
		</properties>
	</adapter>
	<options>
    	<pre-function-handler-list>
    	«IF serviceDef.traceEnabled»
    	«EXPAND cooptrace_pfh_pre_pa(model, serviceDef) FOR this»	
    	«ENDIF»
		</pre-function-handler-list>
		<post-function-handler-list>
		«IF serviceDef.traceEnabled»
    	«EXPAND cooptrace_pfh_post_pa(model, serviceDef) FOR this»	
    	«ENDIF»
		</post-function-handler-list>
	</options>
</porta-applicativa>
«ENDFILE»
«ENDDEFINE»


«REM»file di configurazione per coop-diag«ENDREM»
«DEFINE coopdiagfile(String svn_project_dir, servicegen::SOABEModel model, ServiceDef sd) FOR EJBPABinding»
	«FILE svn_project_dir+"/"+getSpecificEjbConfigRootDir(removeSeparator(sd.codServizio))+"/checked_resources_"+removeSeparator(sd.codServizio).toLowerCase()+".xml"»<?xml version="1.0" encoding="utf-8"?>
<DiagnosticEngineConfig>
«PROTECT CSTART '<!--' CEND '-->' ID getRegionUID("calledResources"+model.codComponente+sd.codServizio)»
	<!--
	inserire qui la cofigurazione delle risorse invocate dal servizio.
	(consultare la documentazione di coop diag per i dettagli sulla
	configurazione dei caller).
	esempi:
  <Caller
    classe = "it.csi.coopdiag.engine.plugin.dbms.DSCaller"
    name = "PIOL_DB"
    codSistema = "PIOL"
    codRisorsa = "PIOL_DB"
    codTipoRisorsa = "dbms-ds"
    descrTipoRisorsa = "Database via Datasource JDBC">
    <Properties>
      <Property name="jndiName" value="java:comp/env/piolDS"/>
      <Property name="configQuery" value="SELECT SYSDATE FROM DUAL"/>
      <Property name="checkTimeout" value="10000"/>
    </Properties>
  </Caller>
 
  <Caller
    classe = "it.csi.coopdiag.engine.plugin.pdpa.PDPACaller"
    name = "PDPA_GWDA_SU"
    codSistema = "PIOL"
    codRisorsa = "GWDA_SU"
    codTipoRisorsa = "pd-pa"
    descrTipoRisorsa = "Infrastruttura di cooperazione C.S.I">
    <Properties>
      <Property name="pdDefConfigType" value="resource"/>
      <Property name="pdDefConfigLocation" value="/gateways/da/defpd_gatewayDA_su.xml"/>
      <Property name="checkTimeout" value="10000"/>
    </Properties>
  </Caller>
  -->   
  <!-- il caller che segue e' stato inserito per non far fallire il caricamento
       della configurazione -->
  <Caller
    classe = "it.csi.coopdiag.engine.plugin.fs.FSCaller"
    name = "DUMMY_FS"
    codSistema = "«model.codProdotto»"
    codRisorsa = "«model.codProdotto»_FS"
    codTipoRisorsa = "fs-rw"
    descrTipoRisorsa = "File system">
    <Properties>
      <Property name="path.root" value="."/>
      <Property name="path.permission" value="rw"/>
      <Property name="path.filetoread" value="TAPPO.txt"/>
    </Properties>
  </Caller>
«ENDPROTECT»
</DiagnosticEngineConfig>
	«ENDFILE»
«ENDDEFINE»

«REM»crea il file di PD nella directory test/xml«ENDREM»
«DEFINE defpdejbfile (String svn_project_dir, servicegen::SOABEModel model, ServiceDef sd) FOR EJBPABinding»
«FILE svn_project_dir+"/"+getTestXmlFilesDir(sd.codServizio)+"/"+pdEJBDefFileName(sd)»<porta-delegata name="@cod_fruitore@.«removeSeparator(sd.codServizio)»">
  <services>
  «EXPAND pdservicedef (model) FOR sd»
  </services>
  <config>
    <url-pa>**not used**</url-pa>
    <pluggable-pd-list chooser-class="it.csi.csi.porte.FixedDelegateChooser">
      <pluggable-pd
        name="«removeSeparator(sd.codServizio)»"
        class="it.csi.csi.porte.ejb20.PortaDelegataEJB"
        url-pa="«fullPAJndiName(model.codProdotto, model.codComponente,sd)»"
        url-qm="«fullQMGRJndiName(model.codProdotto, model.codComponente, sd)»">
        <properties>
          <property name="java.naming.provider.url" value="@be.pa.url@"/>
          «IF model.targetPlatform.code==TargetPlatformCodes::WLS92»
          <!-- initial contxt factory per WLS92 -->
          <property name="java.naming.factory.initial" value="weblogic.jndi.WLInitialContextFactory" />
          «ELSEIF model.targetPlatform.code==TargetPlatformCodes::JBoss43»
          <!-- initial context factory per JBoss43 -->
          <property name="java.naming.factory.initial" value="org.jnp.interfaces.NamingContextFactory" />
          «ENDIF»
        </properties>
      </pluggable-pd>
    </pluggable-pd-list>
    <pre-function-handler-list>
    	«IF sd.traceEnabled»
    	«EXPAND cooptrace_pfh_pre_pd(model, sd) FOR this»	
    	«ENDIF»
		</pre-function-handler-list>
		<post-function-handler-list>
		«IF sd.traceEnabled»
    	«EXPAND cooptrace_pfh_post_pd(model, sd) FOR this»	
    	«ENDIF»
		</post-function-handler-list>
    <queue-manager url=""/>
  </config>
</porta-delegata>
«ENDFILE»
«ENDDEFINE»

«DEFINE defpdsoapfile (String svn_project_dir, servicegen::SOABEModel model, ServiceDef sd) FOR SOAPPABRBinding»
«FILE svn_project_dir+"/"+getTestXmlFilesDir(sd.codServizio)+"/"+pdSOAPDefFileName(sd)»<porta-delegata name="@cod_fruitore@.«removeSeparator(sd.codServizio)»">
  <services>
  «EXPAND pdservicedef (model) FOR sd»
  </services>
  <config>
    <url-pa>**not used**</url-pa>
    <pluggable-pd-list chooser-class="it.csi.csi.porte.FixedDelegateChooser">
      <pluggable-pd
        name="«removeSeparator(sd.codServizio)»"
        class="it.csi.csi.porte.soap.apache.PortaDelegataSoap"
        url-pa="@url_pabr@/«pabrWebContext(model.codComponente, sd.codServizio, this.codBinding, sd.serviceType.toString())»/servlet/rpcrouter"
        url-qm="">
        <properties>
          <!--<property name="csi.ssl.keystore.location" value="c:/progetti/test_csi/resource/client.keystore" />-->
          <!--<property name="csi.ssl.truststore.location" value="c:/progetti/test_csi/resource/client.truststore" />-->
          <!-- <property name="csi.proxyhost" value="proxy.csi.it:80"/> -->
          <!--<property name="csi.auth.basic" value="myuser/mypasswd" />-->
          <!--<property name="csi.connection.timeout" value="30000" />-->
        </properties>
      </pluggable-pd>
    </pluggable-pd-list>
    <queue-manager url=""/>
  </config>
</porta-delegata>
«ENDFILE»
«ENDDEFINE»

«REM»invariante per le varie pd«ENDREM»
«DEFINE pdservicedef(SOABEModel model) FOR ServiceDef»
<service name="«removeSeparator(codServizio)»" public-interface-class="«fullQualifiedServiceInterfaceName(this, model.codProdotto, model.codComponente)»" top-version="«versione»">
      <operations>
      «EXPAND pdopdef (model, codServizio)FOREACH this.operations»
      «IF monitorable»
        <!-- operazione per monitoraggio -->
      	<operation name="testResources" type="synch-call">
          <param-list>
          </param-list>
          <ret-val type="boolean"/>
        </operation>
      «ENDIF»
      «IF diagEnabled»
        <!-- operazioni per diagnostica -->
      	<operation name="selfCheck" type="synch-call">
          <param-list>
          	<param name="alreadyCalled" type="it.csi.coopdiag.api.CalledResource[]"/>
          </param-list>
          <ret-val type="it.csi.coopdiag.api.InvocationNode"/>
      	</operation>
      	<operation name="hasSelfCheck" type="synch-call">
          <param-list>
          </param-list>
          <ret-val type="boolean"/>
      	</operation>
      «ENDIF»
      </operations>
    </service>
«ENDDEFINE»

«DEFINE pdopdef(SOABEModel model, String codServ) FOR Operation»
		<operation name="«name»" type="«opTypeConst(opType)»" «IF since != null»since="«since»"«ENDIF»>
          <param-list>
          «EXPAND pd_op_par(model, codServ) FOREACH this.params»
          «IF opType!=OpTypeEnum::synch»
          <param name="datiMsg" type="it.csi.csi.util.DatiMessaggio" />
          «ENDIF»
          </param-list>
          «LET map2javaType(returnType, model.codProdotto, model.codComponente, codServ) AS retType»
          	«LET retType==null?"void":retType AS retTypeOrVoid»
          	<ret-val type="«retTypeOrVoid»"/>
          	«ENDLET»
          «ENDLET»
        </operation>
«ENDDEFINE»

«DEFINE pd_op_par(SOABEModel model, String codServ) FOR Param»
			<param name="name" type="«map2javaType(type, model.codProdotto, model.codComponente, codServ)»" />
«ENDDEFINE»

«DEFINE defpdejbembeddedinwsfad (String svn_project_dir, servicegen::SOABEModel model, ServiceDef sd) FOR WSFADBinding»
«FILE svn_project_dir+"/"+getSpecificWarResourcesRootDir("wsfad",removeSeparator(sd.codServizio))+"/defpdelegata_embedded_"+removeSeparator(sd.codServizio).toLowerCase()+".xml"»<porta-delegata name="@cod_fruitore@.«removeSeparator(sd.codServizio)»">
  <services>
  «EXPAND pdservicedef (model) FOR sd»
  </services>
  <config>
    <url-pa>**not used**</url-pa>
    <pluggable-pd-list chooser-class="it.csi.csi.porte.FixedDelegateChooser">
      <pluggable-pd
        name="«removeSeparator(sd.codServizio)»"
        class="it.csi.csi.porte.ejb20.PortaDelegataEJB"
        url-pa="«fullPAJndiName(model.codProdotto, model.codComponente, sd)»"
        url-qm="">
        <properties>
        </properties>
      </pluggable-pd>
    </pluggable-pd-list>
    <queue-manager url=""/>
  </config>
</porta-delegata>
«ENDFILE»
«ENDDEFINE»


«DEFINE cooptrace_pfh_pre_pd (servicegen::SOABEModel model, ServiceDef sd) FOR EJBPABinding»<pluggable-fh
         name="PD TXID Handler(pre)"
         class="it.csi.cooptrace.business.handler.PdTracingHandler" >
        <properties>
          <property name="componentname" value="«model.codComponente»" />
          <property name="callername" value="«model.codComponente»" />
         <property name="interfacename" value="«serviceInterfaceName(sd)»" />
       </properties>
      </pluggable-fh>
«ENDDEFINE»

«DEFINE cooptrace_pfh_post_pd (servicegen::SOABEModel model, ServiceDef sd) FOR EJBPABinding»<pluggable-fh
         name="PD TXID Handler(post)"
         class="it.csi.cooptrace.business.handler.PdTracingHandler" >
        <properties>
          <property name="componentname" value="«model.codComponente»" />
          <property name="callername" value="«model.codComponente»" />
          <property name="interfacename" value="«serviceInterfaceName(sd)»" />
        </properties>
      </pluggable-fh>
«ENDDEFINE»

«DEFINE cooptrace_pfh_pre_pa(servicegen::SOABEModel model, ServiceDef sd) FOR EJBPABinding»<pluggable-fh
         name="PA Chiamante TXID Handler(pre)"
         class="it.csi.cooptrace.business.handler.PaTracingHandler" >
        <properties>
           <property name="componentname" value="«model.codComponente»" />
           <property name="callername" value="«model.codComponente»" />
           <property name="interfacename" value="«serviceInterfaceName(sd)»" />
       </properties>
      </pluggable-fh>
«ENDDEFINE»

«DEFINE cooptrace_pfh_post_pa(servicegen::SOABEModel model, ServiceDef sd) FOR EJBPABinding»<pluggable-fh
         name="PA Chiamante TXID Handler(post)"
         class="it.csi.cooptrace.business.handler.PaTracingHandler" >
        <properties>
          <property name="componentname" value="«model.codComponente»" />
          <property name="callername" value="«model.codComponente»" />
          <property name="interfacename" value="«serviceInterfaceName(sd)»" />
        </properties>
      </pluggable-fh>
«ENDDEFINE»


«REM»artefatti per deploy in servizio di naming (1 per componente prodotto)«ENDREM»
«DEFINE registryArtifacts(String svn_project_dir, TargetPlatform tp) FOR SOABEModel»
	«EXPAND registryDeployFile (svn_project_dir,tp) FOR this»
	«EXPAND registryPD(svn_project_dir, this) FOREACH this.serviceimplementations»
«ENDDEFINE»

«DEFINE registryDeployFile(String svn_project_dir, TargetPlatform tp) FOR SOABEModel»
«FILE svn_project_dir+"/"+getfullRegistryDDFileName(codProdotto,codComponente)»<?xml version="1.0" encoding="UTF-8" ?>
<deploy-descriptor 
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
	xsi:noNamespaceSchemaLocation="../../conf/deploy-descriptor.xsd">
	
	<rilascio 
		ambiente="${rilascio.ambiente}" 
		cliente="${rilascio.cliente}" 
		istanza="${rilascio.istanza}" 
		unita-installazione="«codComponente.toLowerCase()»"
		staging="false"
	>
		<prodotto codice="«codProdotto»" versione="«versioneProdotto»">
			<descrizione>${prodotto.descrizione}</descrizione>
		</prodotto>
		<componente codice="«codComponente.toLowerCase()»">
			<descrizione>${componente.descrizione}</descrizione>
		</componente>
	</rilascio>
	
	<lista-servizi>
	    «FOREACH serviceimplementations AS servImpl»
	    «LET servImpl.provides AS sd»
	    	«LET sd.serviceType==SrvTypeEnum::infr ? "I" : (sd.serviceType==SrvTypeEnum::orch ? "O" : "A") AS serviceTypeStr»
		<servizio nome="«removeSeparator(sd.codServizio)»" 
		          versione-intf="«sd.versione»"
		          versione-impl="«sd.versione»" 
		          tipo-servizio="«serviceTypeStr»" 
		          tipo-erogazione="O">
			<versione-retrocompatibile>true</versione-retrocompatibile>
		</servizio>
			«ENDLET»
		«ENDLET»
		«ENDFOREACH»
	</lista-servizi>	
	
	<lista-binding>
	    «FOREACH serviceimplementations AS servImpl»
	    «LET servImpl.provides AS currSD»
	    «FOREACH currSD.bindings AS currBind»
	    <binding servizio="«removeSeparator(currSD.codServizio)»" versione="«currSD.versione»" 
                     protocollo="«decodeTipoInter(currBind,tp)»">
		  <endpoint>
		  «IF currBind.metaType!=WSFADBinding»
		  	<csi-endpoint 
                      pd-file="«removeSeparator(currSD.codServizio)+"/"+getRegistryPDFileName(codProdotto,codComponente,currSD,currBind,tp)»">
		    </csi-endpoint>
		  «ELSE»
		    <ws-endpoint>
		    	<url>${service.«removeSeparator(currSD.codServizio)».«currBind.codBinding».server.prefix}/«wsfadWebContext(codComponente,removeSeparator(currSD.codServizio),currBind.codBinding,currSD.serviceType.toString())»</url>
		    	<wsdl>#####TODO######</wsdl>
		    </ws-endpoint>
		  «ENDIF»
                
		  </endpoint>
		</binding>
		
	    «ENDFOREACH»
	    «ENDLET»
	    «ENDFOREACH»
		
		
	</lista-binding>
</deploy-descriptor>

«ENDFILE»
«ENDDEFINE»

«DEFINE registryPD(String svn_project_dir, SOABEModel model) FOR ServiceImpl»
«ENDDEFINE»




«REM»file di configurazione per features asincrone«ENDREM»

«DEFINE asynchCfgFiles(String svn_project_dir, SOABEModel model, EJBPABinding pa) FOR ServiceDef»
«FILE svn_project_dir+"/"+paConfigDir(model.codComponente,this)+"/"+qmgrDefFileName(this)»<queue-manager-conf
  listening-url="*not-used*" name="«getLoggerPrefixForComponent(model.codProdotto, model.codComponente)».PDD_QMGR" >
  <jms-queue-jndi-props>
<!-- la configurazione jndi del server jms e' implicita nella maggiorparte dei casi -->
<!--    <prop name="java.naming.provider.url" value="t3://censerv1wls1.csi.it:7001" />-->
<!--    <prop name="java.naming.factory.initial" value="weblogic.jndi.WLInitialContextFactory" />-->
  </jms-queue-jndi-props>
  <jms-queue-connection-factory jndi-name="«queueConnectionFactoryJndiName()»" />
  <service-activator-config
    activated-interface="«fullQualifiedServiceInterfaceName(this, model.codProdotto, model.codComponente)»"
    retry-delay="10000"
    max-retry="10"
    counter-name="«asynchCounterTableName(this)»"
  />
  <!-- NOTA: il separatore nella PA NAME non deve essere '/' perche' il sistema
       lo ricerca come '.' -->
  <port-queue-map>
    <!-- il nome della porta deve coincidere con il nasme nel pluggable-pd del client! -->
    <map port-name="«removeSeparator(codServizio)»" 
    	 queue-jndi-name="«paQueueJndiName(model.codProdotto, model.codComponente, this, pa.codBinding)»" />
  </port-queue-map>
</queue-manager-conf>
«ENDFILE»

«REM»file di istruzioni per creazione code e tabelle«ENDREM»
«FILE svn_project_dir+"/"+getDocsRootDir()+"/"+removeSeparator(codServizio)+"/README_ASYNCH.txt"»
Istruzioni per la creazione degli oggetti di supporto all'asincronicità
del servizio "«codServizio»".

1) creare la tabella del contatore per i retry lanciando lo script 
   "create_counter_«removeSeparator(this.codServizio)».sql"»;
2) verificare l'esistenza sull'ambiente di deploy della QueueConnectionFactory
   di nome "«queueConnectionFactoryJndiName()»";
3) creare un datasource con le seguenti caratteristiche:
   - name: Counter«toCamel(codServizio)»TxDS (standard opzionale)
   - jndi-name: «counterDSJndiName(model.codProdotto, model.codComponente, this)»;
   - puntamento al DB che ospita la tabella creata al punto (1);
4) creare la coda associata alla PA del servizio, con jndi name = «paQueueJndiName(model.codProdotto, model.codComponente, this, pa.codBinding)»;
«ENDFILE»
«ENDDEFINE»


«DEFINE soappabrdeploy (String svn_project_dir, servicegen::SOABEModel model, servicedef::ServiceDef serviceDef) FOR servicedef::SOAPPABRBinding»
«FILE svn_project_dir+"/"+getSpecificWarConfigRootDir("pabr",removeSeparator(serviceDef.codServizio))+"/WEB-INF/deploysoapejb-"+removeSeparator(serviceDef.codServizio).toLowerCase()+".xml"»<?xml version="1.0" encoding="UTF-8"?>
<isd:service xmlns:isd="http://xml.apache.org/xml-soap/deployment" id="urn:«removeSeparator(serviceDef.codServizio)»">
  <isd:provider type="it.csi.csi.porte.soap.apache.StatelessEJBProvider"
                scope="Application" methods="invokeSynch invokeAsynch">
    <isd:option key="JNDIName" value="«fullPAJndiName(model.codProdotto, model.codComponente,serviceDef)»"/>
    <isd:option key="app.context.name" value="«getLoggerPrefixForComponent(model.codProdotto, model.codComponente)»" />
  </isd:provider>
  <isd:faultListener>org.apache.soap.server.ExceptionFaultListener</isd:faultListener>
  <isd:mappings defaultRegistryClass="it.csi.csi.porte.soap.apache.GeneralizedMappingRegistry">
  </isd:mappings>
</isd:service>
«ENDFILE»
«ENDDEFINE»


«REM»
	files per coop-trace:
	-per ogni componente:
		-frammento di configurazione log4j.xml per server host (v.par. 5.2.1)
		-frammento di configurazione log4j.properties per on/off log4j
	-per ogni binding PA EJB:
		-inserimento nelle def pd e pa dei PFH di coop-trace (viene fatto in appositi template richiamati dai template che creano 
		 le def pd e pa  
«ENDREM»
«DEFINE cooptracefiles(String svn_project_dir) FOR SOABEModel»
«FILE svn_project_dir+"/"+getDocsRootDir()+"/log4j_"+codComponente+".xml"»<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
<!-- deve essere inserito nella directory 
    /appserv/bea/beahome/beaConfigManaged/config/<dominio> -->
<log4j:configuration debug="true" xmlns:log4j="http://jakarta.apache.org/log4j/">
	<appender name="ASYNC" class="org.apache.log4j.AsyncAppender">
        	<param name="Blocking" value="false"/>
		<param name="BufferSize" value="1000" />
		<appender-ref ref="JMSAppender" />
	</appender>
	<appender name="JMSAppender" class="it.csi.util.log4jext.integration.JMSQueueAppender">
        	<param name="Threshold" value="DEBUG" />
		<param name="InitialContextFactory" value="weblogic.jndi.WLInitialContextFactory" />
		<param name="ProviderUrl" value="@URL_CCOPTRACE@" />
		<param name="QueueConnectionFactoryBindingName" value="jms/cooptraceCF" />
		<param name="QueueBindingName" value="jms/cooptraceDQ" />
       </appender>
        
           <logger name="«codComponente».jmsAppender" additivity="false">
              <level value="INFO" />
              <appender-ref ref="ASYNC" />
       </logger>
</log4j:configuration>
«ENDFILE»
«ENDDEFINE»

«DEFINE cooptrace_logger_cfg FOR SOABEModel»
#-------------------------------------------------------------------------
# Configurazione log per COOP-TRACE per il componente «codComponente»
# L'output va sull'appender complessivo già definito per il componente
# ma può essere acceso/spento separatamente
#-------------------------------------------------------------------------
log4j.logger.«codComponente».cooptrace=DEBUG, «codComponente».file
log4j.additivity.«codComponente».cooptrace =false
«ENDDEFINE»

«REM»
Questa configurazione è da rivedere perchè non si capisce bene
qual'è l'appender su cui deve scrivere.
«ENDREM»
«DEFINE cooptrace_stopwatch_cfg FOR SOABEModel»
log4j.logger.«codComponente».cooptrace.util.stopwatch =INFO, «codComponente»
log4j.additivity.«codComponente».cooptrace.util.stopwatch=false
log4j.appender.«codComponente»=org.apache.log4j.RollingFileAppender
log4j.appender.«codComponente».File=[pathfile]/cooptrace_server<X>.csv
log4j.appender.«codComponente».layout=org.apache.log4j.PatternLayout
log4j.appender.«codComponente».MaxFileSize=1000KB
log4j.appender.«codComponente».MaxBackupIndex=2
log4j.appender.«codComponente».layout.ConversionPattern=%t,%d{yyyy-MM-dd HH:mm:ss},%X{<componentName>.cooptrace.stopwatch.context},%X{«codComponente».cooptrace. stopwatch.elapsed},%m%n
«ENDDEFINE»





